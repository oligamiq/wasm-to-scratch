#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod closure {
    use std::{fmt, mem::{self, ManuallyDrop}};
    use crate::{
        convert::{
            FromWasmAbi, IntoWasmAbi, OptionIntoWasmAbi, RefFromWasmAbi, ReturnWasmAbi,
            WasmAbi, WasmRet,
        },
        describe::{inform, CLOSURE, EXTERNREF},
        throw_str, SbValue, UnwrapThrowExt as _, WasmDescribe,
    };
    pub struct Closure<T: ?Sized> {
        sb: ManuallyDrop<SbValue>,
        data: ManuallyDrop<Box<T>>,
    }
    union FatPtr<T: ?Sized> {
        ptr: *mut T,
        fields: (usize, usize),
    }
    impl<T> Closure<T>
    where
        T: ?Sized + WasmClosure,
    {
        /// Creates a new instance of `Closure` from the provided Rust function.
        ///
        /// Note that the closure provided here, `F`, has a few requirements
        /// associated with it:
        ///
        /// * It must implement `Fn` or `FnMut` (for `FnOnce` functions see
        ///   `Closure::once` and `Closure::once_into_sb`).
        ///
        /// * It must be `'static`, aka no stack references (use the `move`
        ///   keyword).
        ///
        /// * It can have at most 7 arguments.
        ///
        /// * Its arguments and return values are all types that can be shared with
        ///   JS (i.e. have `#[wasm_bindgen]` annotations or are simple numbers,
        ///   etc.)
        pub fn new<F>(t: F) -> Closure<T>
        where
            F: IntoWasmClosure<T> + 'static,
        {
            Closure::wrap(Box::new(t).unsize())
        }
        /// A more direct version of `Closure::new` which creates a `Closure` from
        /// a `Box<dyn Fn>`/`Box<dyn FnMut>`, which is how it's kept internally.
        pub fn wrap(mut data: Box<T>) -> Closure<T> {
            match (&mem::size_of::<*const T>(), &mem::size_of::<FatPtr<T>>()) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            };
            let (a, b) = unsafe {
                FatPtr {
                    ptr: &mut *data as *mut T,
                }
                    .fields
            };
            extern "C" fn describe<T: WasmClosure + ?Sized>() {
                inform(CLOSURE);
                T::describe()
            }
            #[inline(never)]
            unsafe fn breaks_if_inlined<T: WasmClosure + ?Sized>(
                a: usize,
                b: usize,
            ) -> u32 {
                super::__wasm_sb_bindgen_describe_closure(
                    a as u32,
                    b as u32,
                    describe::<T> as u32,
                )
            }
            let idx = unsafe { breaks_if_inlined::<T>(a, b) };
            Closure {
                sb: ManuallyDrop::new(SbValue::_new(idx)),
                data: ManuallyDrop::new(data),
            }
        }
        /// Release memory management of this closure from Rust to the JS GC.
        ///
        /// When a `Closure` is dropped it will release the Rust memory and
        /// invalidate the associated JS closure, but this isn't always desired.
        /// Some callbacks are alive for the entire duration of the program or for a
        /// lifetime dynamically managed by the JS GC. This function can be used
        /// to drop this `Closure` while keeping the associated JS function still
        /// valid.
        ///
        /// If the platform supports weak references, the Rust memory will be
        /// reclaimed when the JS closure is GC'd. If weak references is not
        /// supported, this can be dangerous if this function is called many times
        /// in an application because the memory leak will overwhelm the page
        /// quickly and crash the wasm.
        pub fn into_sb_value(self) -> SbValue {
            let idx = self.sb.idx;
            mem::forget(self);
            SbValue::_new(idx)
        }
        /// Same as `into_sb_value`, but doesn't return a value.
        pub fn forget(self) {
            drop(self.into_sb_value());
        }
    }
    impl Closure<dyn FnOnce()> {
        /// Create a `Closure` from a function that can only be called once.
        ///
        /// Since we have no way of enforcing that JS cannot attempt to call this
        /// `FnOne(A...) -> R` more than once, this produces a `Closure<dyn FnMut(A...)
        /// -> R>` that will dynamically throw a JavaScript error if called more
        /// than once.
        ///
        /// # Example
        ///
        /// ```rust,no_run
        /// use wasm_bindgen::prelude::*;
        ///
        /// // Create an non-`Copy`, owned `String`.
        /// let mut s = String::from("Hello");
        ///
        /// // Close over `s`. Since `f` returns `s`, it is `FnOnce` and can only be
        /// // called once. If it was called a second time, it wouldn't have any `s`
        /// // to work with anymore!
        /// let f = move || {
        ///     s += ", World!";
        ///     s
        /// };
        ///
        /// // Create a `Closure` from `f`. Note that the `Closure`'s type parameter
        /// // is `FnMut`, even though `f` is `FnOnce`.
        /// let closure: Closure<dyn FnMut() -> String> = Closure::once(f);
        /// ```
        pub fn once<F, A, R>(fn_once: F) -> Closure<F::FnMut>
        where
            F: 'static + WasmClosureFnOnce<A, R>,
        {
            Closure::wrap(fn_once.into_fn_mut())
        }
        /// Convert a `FnOnce(A...) -> R` into a JavaScript `Function` object.
        ///
        /// If the JavaScript function is invoked more than once, it will throw an
        /// exception.
        ///
        /// Unlike `Closure::once`, this does *not* return a `Closure` that can be
        /// dropped before the function is invoked to deallocate the closure. The
        /// only way the `FnOnce` is deallocated is by calling the JavaScript
        /// function. If the JavaScript function is never called then the `FnOnce`
        /// and everything it closes over will leak.
        ///
        /// ```rust,ignore
        /// use wasm_bindgen::{prelude::*, SbCast};
        ///
        /// let f = Closure::once_into_sb(move || {
        ///     // ...
        /// });
        ///
        /// assert!(f.is_instance_of::<sb_sys::Function>());
        /// ```
        pub fn once_into_sb<F, A, R>(fn_once: F) -> SbValue
        where
            F: 'static + WasmClosureFnOnce<A, R>,
        {
            fn_once.into_sb_function()
        }
    }
    #[doc(hidden)]
    pub trait WasmClosureFnOnce<A, R>: 'static {
        type FnMut: ?Sized + 'static + WasmClosure;
        fn into_fn_mut(self) -> Box<Self::FnMut>;
        fn into_sb_function(self) -> SbValue;
    }
    impl<T: ?Sized> AsRef<SbValue> for Closure<T> {
        fn as_ref(&self) -> &SbValue {
            &self.sb
        }
    }
    impl<T> WasmDescribe for Closure<T>
    where
        T: WasmClosure + ?Sized,
    {
        fn describe() {
            inform(EXTERNREF);
        }
    }
    impl<'a, T> IntoWasmAbi for &'a Closure<T>
    where
        T: WasmClosure + ?Sized,
    {
        type Abi = u32;
        fn into_abi(self) -> u32 {
            (&*self.sb).into_abi()
        }
    }
    impl<'a, T> OptionIntoWasmAbi for &'a Closure<T>
    where
        T: WasmClosure + ?Sized,
    {
        fn none() -> Self::Abi {
            0
        }
    }
    fn _check() {
        fn _assert<T: IntoWasmAbi>() {}
        _assert::<&Closure<dyn Fn()>>();
        _assert::<&Closure<dyn Fn(String)>>();
        _assert::<&Closure<dyn Fn() -> String>>();
        _assert::<&Closure<dyn FnMut()>>();
        _assert::<&Closure<dyn FnMut(String)>>();
        _assert::<&Closure<dyn FnMut() -> String>>();
    }
    impl<T> fmt::Debug for Closure<T>
    where
        T: ?Sized,
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(format_args!("Closure {{ ... }}"))
        }
    }
    impl<T> Drop for Closure<T>
    where
        T: ?Sized,
    {
        fn drop(&mut self) {
            unsafe {
                if super::__wasm_sb_bindgen_cb_drop(self.sb.idx) != 0 {
                    ManuallyDrop::drop(&mut self.data);
                }
            }
        }
    }
    /// An internal trait for the `Closure` type.
    ///
    /// This trait is not stable and it's not recommended to use this in bounds or
    /// implement yourself.
    #[doc(hidden)]
    pub unsafe trait WasmClosure {
        fn describe();
    }
    #[doc(hidden)]
    pub trait IntoWasmClosure<T: ?Sized> {
        fn unsize(self: Box<Self>) -> Box<T>;
    }
    unsafe impl<R> WasmClosure for dyn Fn() -> R + 'static
    where
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn() -> R = FatPtr { fields: (a, b) }.ptr;
                    (*f)()
                };
                ret.return_abi().into()
            }
            inform(invoke::<R> as u32);
            unsafe extern fn destroy<R: ReturnWasmAbi>(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn() -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<R> WasmClosure for dyn FnMut() -> R + 'static
    where
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut() -> R = FatPtr { fields: (a, b) }.ptr;
                    let f = f as *mut dyn FnMut() -> R;
                    (*f)()
                };
                ret.return_abi().into()
            }
            inform(invoke::<R> as u32);
            unsafe extern fn destroy<R: ReturnWasmAbi>(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut() -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, R> WasmClosureFnOnce<(), R> for T
    where
        T: 'static + FnOnce() -> R,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut() -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move || {
                let me = me.take().expect_throw("FnOnce called more than once");
                me()
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move || {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me();
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut() -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, R> IntoWasmClosure<dyn FnMut() -> R> for T
    where
        T: 'static + FnMut() -> R,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut() -> R> {
            self
        }
    }
    impl<T, R> IntoWasmClosure<dyn Fn() -> R> for T
    where
        T: 'static + Fn() -> R,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn() -> R> {
            self
        }
    }
    unsafe impl<A, R> WasmClosure for dyn Fn(A) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<A: FromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A) -> R = FatPtr { fields: (a, b) }.ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    (*f)(A)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, R> as u32);
            unsafe extern fn destroy<A: FromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, R> WasmClosure for dyn FnMut(A) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<A: FromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A) -> R = FatPtr { fields: (a, b) }.ptr;
                    let f = f as *mut dyn FnMut(A) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    (*f)(A)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, R> as u32);
            unsafe extern fn destroy<A: FromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, R> WasmClosureFnOnce<(A), R> for T
    where
        T: 'static + FnOnce(A) -> R,
        A: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, R> IntoWasmClosure<dyn FnMut(A) -> R> for T
    where
        T: 'static + FnMut(A) -> R,
        A: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A) -> R> {
            self
        }
    }
    impl<T, A, R> IntoWasmClosure<dyn Fn(A) -> R> for T
    where
        T: 'static + Fn(A) -> R,
        A: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A) -> R> {
            self
        }
    }
    unsafe impl<A, B, R> WasmClosure for dyn Fn(A, B) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B) -> R = FatPtr { fields: (a, b) }.ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    (*f)(A, B)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, R> as u32);
            unsafe extern fn destroy<A: FromWasmAbi, B: FromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, R> WasmClosure for dyn FnMut(A, B) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B) -> R = FatPtr { fields: (a, b) }.ptr;
                    let f = f as *mut dyn FnMut(A, B) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    (*f)(A, B)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, R> as u32);
            unsafe extern fn destroy<A: FromWasmAbi, B: FromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, R> WasmClosureFnOnce<(A, B), R> for T
    where
        T: 'static + FnOnce(A, B) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, B, R> IntoWasmClosure<dyn FnMut(A, B) -> R> for T
    where
        T: 'static + FnMut(A, B) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B) -> R> {
            self
        }
    }
    impl<T, A, B, R> IntoWasmClosure<dyn Fn(A, B) -> R> for T
    where
        T: 'static + Fn(A, B) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B) -> R> {
            self
        }
    }
    unsafe impl<A, B, C, R> WasmClosure for dyn Fn(A, B, C) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B, C) -> R = FatPtr { fields: (a, b) }.ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    (*f)(A, B, C)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B, C) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, C, R> WasmClosure for dyn FnMut(A, B, C) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B, C) -> R = FatPtr { fields: (a, b) }
                        .ptr;
                    let f = f as *mut dyn FnMut(A, B, C) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    (*f)(A, B, C)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B, C) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, C, R> WasmClosureFnOnce<(A, B, C), R> for T
    where
        T: 'static + FnOnce(A, B, C) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B, C) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B, C| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B, C)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B, C| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B, C);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B, C) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, B, C, R> IntoWasmClosure<dyn FnMut(A, B, C) -> R> for T
    where
        T: 'static + FnMut(A, B, C) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B, C) -> R> {
            self
        }
    }
    impl<T, A, B, C, R> IntoWasmClosure<dyn Fn(A, B, C) -> R> for T
    where
        T: 'static + Fn(A, B, C) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B, C) -> R> {
            self
        }
    }
    unsafe impl<A, B, C, D, R> WasmClosure for dyn Fn(A, B, C, D) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B, C, D) -> R = FatPtr { fields: (a, b) }
                        .ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    (*f)(A, B, C, D)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B, C, D) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, C, D, R> WasmClosure for dyn FnMut(A, B, C, D) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B, C, D) -> R = FatPtr { fields: (a, b) }
                        .ptr;
                    let f = f as *mut dyn FnMut(A, B, C, D) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    (*f)(A, B, C, D)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B, C, D) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, C, D, R> WasmClosureFnOnce<(A, B, C, D), R> for T
    where
        T: 'static + FnOnce(A, B, C, D) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B, C, D) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B, C, D| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B, C, D)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B, C, D| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B, C, D);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B, C, D) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, B, C, D, R> IntoWasmClosure<dyn FnMut(A, B, C, D) -> R> for T
    where
        T: 'static + FnMut(A, B, C, D) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B, C, D) -> R> {
            self
        }
    }
    impl<T, A, B, C, D, R> IntoWasmClosure<dyn Fn(A, B, C, D) -> R> for T
    where
        T: 'static + Fn(A, B, C, D) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B, C, D) -> R> {
            self
        }
    }
    unsafe impl<A, B, C, D, E, R> WasmClosure for dyn Fn(A, B, C, D, E) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B, C, D, E) -> R = FatPtr { fields: (a, b) }
                        .ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    (*f)(A, B, C, D, E)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B, C, D, E) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, C, D, E, R> WasmClosure for dyn FnMut(A, B, C, D, E) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B, C, D, E) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let f = f as *mut dyn FnMut(A, B, C, D, E) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    (*f)(A, B, C, D, E)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B, C, D, E) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, C, D, E, R> WasmClosureFnOnce<(A, B, C, D, E), R> for T
    where
        T: 'static + FnOnce(A, B, C, D, E) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B, C, D, E) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B, C, D, E| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B, C, D, E)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B, C, D, E| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B, C, D, E);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B, C, D, E) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, B, C, D, E, R> IntoWasmClosure<dyn FnMut(A, B, C, D, E) -> R> for T
    where
        T: 'static + FnMut(A, B, C, D, E) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B, C, D, E) -> R> {
            self
        }
    }
    impl<T, A, B, C, D, E, R> IntoWasmClosure<dyn Fn(A, B, C, D, E) -> R> for T
    where
        T: 'static + Fn(A, B, C, D, E) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B, C, D, E) -> R> {
            self
        }
    }
    unsafe impl<A, B, C, D, E, F, R> WasmClosure
    for dyn Fn(A, B, C, D, E, F) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
                f1: <F::Abi as WasmAbi>::Prim1,
                f2: <F::Abi as WasmAbi>::Prim2,
                f3: <F::Abi as WasmAbi>::Prim3,
                f4: <F::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B, C, D, E, F) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                    (*f)(A, B, C, D, E, F)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, F, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B, C, D, E, F) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, F, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, C, D, E, F, R> WasmClosure
    for dyn FnMut(A, B, C, D, E, F) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
                f1: <F::Abi as WasmAbi>::Prim1,
                f2: <F::Abi as WasmAbi>::Prim2,
                f3: <F::Abi as WasmAbi>::Prim3,
                f4: <F::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B, C, D, E, F) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let f = f as *mut dyn FnMut(A, B, C, D, E, F) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                    (*f)(A, B, C, D, E, F)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, F, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B, C, D, E, F) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, F, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, C, D, E, F, R> WasmClosureFnOnce<(A, B, C, D, E, F), R> for T
    where
        T: 'static + FnOnce(A, B, C, D, E, F) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B, C, D, E, F) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B, C, D, E, F| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B, C, D, E, F)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B, C, D, E, F| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B, C, D, E, F);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B, C, D, E, F) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, B, C, D, E, F, R> IntoWasmClosure<dyn FnMut(A, B, C, D, E, F) -> R> for T
    where
        T: 'static + FnMut(A, B, C, D, E, F) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B, C, D, E, F) -> R> {
            self
        }
    }
    impl<T, A, B, C, D, E, F, R> IntoWasmClosure<dyn Fn(A, B, C, D, E, F) -> R> for T
    where
        T: 'static + Fn(A, B, C, D, E, F) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B, C, D, E, F) -> R> {
            self
        }
    }
    unsafe impl<A, B, C, D, E, F, G, R> WasmClosure
    for dyn Fn(A, B, C, D, E, F, G) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
                f1: <F::Abi as WasmAbi>::Prim1,
                f2: <F::Abi as WasmAbi>::Prim2,
                f3: <F::Abi as WasmAbi>::Prim3,
                f4: <F::Abi as WasmAbi>::Prim4,
                g1: <G::Abi as WasmAbi>::Prim1,
                g2: <G::Abi as WasmAbi>::Prim2,
                g3: <G::Abi as WasmAbi>::Prim3,
                g4: <G::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B, C, D, E, F, G) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                    let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                    (*f)(A, B, C, D, E, F, G)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, F, G, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B, C, D, E, F, G) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, F, G, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, C, D, E, F, G, R> WasmClosure
    for dyn FnMut(A, B, C, D, E, F, G) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
                f1: <F::Abi as WasmAbi>::Prim1,
                f2: <F::Abi as WasmAbi>::Prim2,
                f3: <F::Abi as WasmAbi>::Prim3,
                f4: <F::Abi as WasmAbi>::Prim4,
                g1: <G::Abi as WasmAbi>::Prim1,
                g2: <G::Abi as WasmAbi>::Prim2,
                g3: <G::Abi as WasmAbi>::Prim3,
                g4: <G::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B, C, D, E, F, G) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let f = f as *mut dyn FnMut(A, B, C, D, E, F, G) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                    let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                    (*f)(A, B, C, D, E, F, G)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, F, G, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B, C, D, E, F, G) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, F, G, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, C, D, E, F, G, R> WasmClosureFnOnce<(A, B, C, D, E, F, G), R> for T
    where
        T: 'static + FnOnce(A, B, C, D, E, F, G) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B, C, D, E, F, G) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B, C, D, E, F, G| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B, C, D, E, F, G)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B, C, D, E, F, G| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B, C, D, E, F, G);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B, C, D, E, F, G) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<T, A, B, C, D, E, F, G, R> IntoWasmClosure<dyn FnMut(A, B, C, D, E, F, G) -> R>
    for T
    where
        T: 'static + FnMut(A, B, C, D, E, F, G) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B, C, D, E, F, G) -> R> {
            self
        }
    }
    impl<T, A, B, C, D, E, F, G, R> IntoWasmClosure<dyn Fn(A, B, C, D, E, F, G) -> R>
    for T
    where
        T: 'static + Fn(A, B, C, D, E, F, G) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B, C, D, E, F, G) -> R> {
            self
        }
    }
    unsafe impl<A, B, C, D, E, F, G, H, R> WasmClosure
    for dyn Fn(A, B, C, D, E, F, G, H) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        H: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                H: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
                f1: <F::Abi as WasmAbi>::Prim1,
                f2: <F::Abi as WasmAbi>::Prim2,
                f3: <F::Abi as WasmAbi>::Prim3,
                f4: <F::Abi as WasmAbi>::Prim4,
                g1: <G::Abi as WasmAbi>::Prim1,
                g2: <G::Abi as WasmAbi>::Prim2,
                g3: <G::Abi as WasmAbi>::Prim3,
                g4: <G::Abi as WasmAbi>::Prim4,
                h1: <H::Abi as WasmAbi>::Prim1,
                h2: <H::Abi as WasmAbi>::Prim2,
                h3: <H::Abi as WasmAbi>::Prim3,
                h4: <H::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(A, B, C, D, E, F, G, H) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                    let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                    let H = <H as FromWasmAbi>::from_abi(H::Abi::join(h1, h2, h3, h4));
                    (*f)(A, B, C, D, E, F, G, H)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, F, G, H, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                H: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(A, B, C, D, E, F, G, H) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, F, G, H, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, B, C, D, E, F, G, H, R> WasmClosure
    for dyn FnMut(A, B, C, D, E, F, G, H) -> R + 'static
    where
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        H: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                H: FromWasmAbi,
                R: ReturnWasmAbi,
            >(
                a: usize,
                b: usize,
                a1: <A::Abi as WasmAbi>::Prim1,
                a2: <A::Abi as WasmAbi>::Prim2,
                a3: <A::Abi as WasmAbi>::Prim3,
                a4: <A::Abi as WasmAbi>::Prim4,
                b1: <B::Abi as WasmAbi>::Prim1,
                b2: <B::Abi as WasmAbi>::Prim2,
                b3: <B::Abi as WasmAbi>::Prim3,
                b4: <B::Abi as WasmAbi>::Prim4,
                c1: <C::Abi as WasmAbi>::Prim1,
                c2: <C::Abi as WasmAbi>::Prim2,
                c3: <C::Abi as WasmAbi>::Prim3,
                c4: <C::Abi as WasmAbi>::Prim4,
                d1: <D::Abi as WasmAbi>::Prim1,
                d2: <D::Abi as WasmAbi>::Prim2,
                d3: <D::Abi as WasmAbi>::Prim3,
                d4: <D::Abi as WasmAbi>::Prim4,
                e1: <E::Abi as WasmAbi>::Prim1,
                e2: <E::Abi as WasmAbi>::Prim2,
                e3: <E::Abi as WasmAbi>::Prim3,
                e4: <E::Abi as WasmAbi>::Prim4,
                f1: <F::Abi as WasmAbi>::Prim1,
                f2: <F::Abi as WasmAbi>::Prim2,
                f3: <F::Abi as WasmAbi>::Prim3,
                f4: <F::Abi as WasmAbi>::Prim4,
                g1: <G::Abi as WasmAbi>::Prim1,
                g2: <G::Abi as WasmAbi>::Prim2,
                g3: <G::Abi as WasmAbi>::Prim3,
                g4: <G::Abi as WasmAbi>::Prim4,
                h1: <H::Abi as WasmAbi>::Prim1,
                h2: <H::Abi as WasmAbi>::Prim2,
                h3: <H::Abi as WasmAbi>::Prim3,
                h4: <H::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(A, B, C, D, E, F, G, H) -> R = FatPtr {
                        fields: (a, b),
                    }
                        .ptr;
                    let f = f as *mut dyn FnMut(A, B, C, D, E, F, G, H) -> R;
                    let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                    let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                    let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                    let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                    let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                    let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                    let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                    let H = <H as FromWasmAbi>::from_abi(H::Abi::join(h1, h2, h3, h4));
                    (*f)(A, B, C, D, E, F, G, H)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, B, C, D, E, F, G, H, R> as u32);
            unsafe extern fn destroy<
                A: FromWasmAbi,
                B: FromWasmAbi,
                C: FromWasmAbi,
                D: FromWasmAbi,
                E: FromWasmAbi,
                F: FromWasmAbi,
                G: FromWasmAbi,
                H: FromWasmAbi,
                R: ReturnWasmAbi,
            >(a: usize, b: usize) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(A, B, C, D, E, F, G, H) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, B, C, D, E, F, G, H, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case, unused_parens)]
    impl<T, A, B, C, D, E, F, G, H, R> WasmClosureFnOnce<(A, B, C, D, E, F, G, H), R>
    for T
    where
        T: 'static + FnOnce(A, B, C, D, E, F, G, H) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        H: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(A, B, C, D, E, F, G, H) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |A, B, C, D, E, F, G, H| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(A, B, C, D, E, F, G, H)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use std::rc::Rc;
            use crate::__rt::WasmRefCell;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |A, B, C, D, E, F, G, H| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(A, B, C, D, E, F, G, H);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(A, B, C, D, E, F, G, H) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
    impl<
        T,
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H,
        R,
    > IntoWasmClosure<dyn FnMut(A, B, C, D, E, F, G, H) -> R> for T
    where
        T: 'static + FnMut(A, B, C, D, E, F, G, H) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        H: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn FnMut(A, B, C, D, E, F, G, H) -> R> {
            self
        }
    }
    impl<
        T,
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H,
        R,
    > IntoWasmClosure<dyn Fn(A, B, C, D, E, F, G, H) -> R> for T
    where
        T: 'static + Fn(A, B, C, D, E, F, G, H) -> R,
        A: FromWasmAbi + 'static,
        B: FromWasmAbi + 'static,
        C: FromWasmAbi + 'static,
        D: FromWasmAbi + 'static,
        E: FromWasmAbi + 'static,
        F: FromWasmAbi + 'static,
        G: FromWasmAbi + 'static,
        H: FromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        fn unsize(self: Box<Self>) -> Box<dyn Fn(A, B, C, D, E, F, G, H) -> R> {
            self
        }
    }
    unsafe impl<A, R> WasmClosure for dyn Fn(&A) -> R
    where
        A: RefFromWasmAbi,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<A: RefFromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
                arg1: <A::Abi as WasmAbi>::Prim1,
                arg2: <A::Abi as WasmAbi>::Prim2,
                arg3: <A::Abi as WasmAbi>::Prim3,
                arg4: <A::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked after being dropped");
                }
                let ret = {
                    let f: *const dyn Fn(&A) -> R = FatPtr { fields: (a, b) }.ptr;
                    let arg = <A as RefFromWasmAbi>::ref_from_abi(
                        A::Abi::join(arg1, arg2, arg3, arg4),
                    );
                    (*f)(&*arg)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, R> as u32);
            unsafe extern "C" fn destroy<A: RefFromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn Fn(&A) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, R> as u32);
            <&Self>::describe();
        }
    }
    unsafe impl<A, R> WasmClosure for dyn FnMut(&A) -> R
    where
        A: RefFromWasmAbi,
        R: ReturnWasmAbi + 'static,
    {
        fn describe() {
            #[allow(non_snake_case)]
            unsafe extern "C" fn invoke<A: RefFromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
                arg1: <A::Abi as WasmAbi>::Prim1,
                arg2: <A::Abi as WasmAbi>::Prim2,
                arg3: <A::Abi as WasmAbi>::Prim3,
                arg4: <A::Abi as WasmAbi>::Prim4,
            ) -> WasmRet<R::Abi> {
                if a == 0 {
                    throw_str("closure invoked recursively or after being dropped");
                }
                let ret = {
                    let f: *const dyn FnMut(&A) -> R = FatPtr { fields: (a, b) }.ptr;
                    let f = f as *mut dyn FnMut(&A) -> R;
                    let arg = <A as RefFromWasmAbi>::ref_from_abi(
                        A::Abi::join(arg1, arg2, arg3, arg4),
                    );
                    (*f)(&*arg)
                };
                ret.return_abi().into()
            }
            inform(invoke::<A, R> as u32);
            unsafe extern "C" fn destroy<A: RefFromWasmAbi, R: ReturnWasmAbi>(
                a: usize,
                b: usize,
            ) {
                if a == 0 {
                    return;
                }
                drop(
                    Box::from_raw(
                        FatPtr::<dyn FnMut(&A) -> R> {
                            fields: (a, b),
                        }
                            .ptr,
                    ),
                );
            }
            inform(destroy::<A, R> as u32);
            <&mut Self>::describe();
        }
    }
    #[allow(non_snake_case)]
    impl<T, A, R> WasmClosureFnOnce<(&A,), R> for T
    where
        T: 'static + FnOnce(&A) -> R,
        A: RefFromWasmAbi + 'static,
        R: ReturnWasmAbi + 'static,
    {
        type FnMut = dyn FnMut(&A) -> R;
        fn into_fn_mut(self) -> Box<Self::FnMut> {
            let mut me = Some(self);
            Box::new(move |arg| {
                let me = me.take().expect_throw("FnOnce called more than once");
                me(arg)
            })
        }
        fn into_sb_function(self) -> SbValue {
            use crate::__rt::WasmRefCell;
            use std::rc::Rc;
            let mut me = Some(self);
            let rc1 = Rc::new(WasmRefCell::new(None));
            let rc2 = rc1.clone();
            let closure = Closure::wrap(
                Box::new(move |arg: &A| {
                    let me = me.take().expect_throw("FnOnce called more than once");
                    let result = me(arg);
                    if true {
                        match (&Rc::strong_count(&rc2), &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    let option_closure = rc2.borrow_mut().take();
                    if true {
                        if !option_closure.is_some() {
                            ::core::panicking::panic(
                                "assertion failed: option_closure.is_some()",
                            )
                        }
                    }
                    drop(option_closure);
                    result
                }) as Box<dyn FnMut(&A) -> R>,
            );
            let sb_val = closure.as_ref().clone();
            *rc1.borrow_mut() = Some(closure);
            if true {
                match (&Rc::strong_count(&rc1), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            drop(rc1);
            sb_val
        }
    }
}
pub mod convert {
    pub mod cast {
        use crate::{SbValue, WasmDescribe};
        pub trait SbCast
        where
            Self: AsRef<SbValue> + Into<SbValue>,
        {
            /// Test whether this SB value has a type `T`.
            ///
            /// This method will dynamically check to see if this SB object can be
            /// casted to the SB object of type `T`. Usually this uses the `instanceof`
            /// operator. This also works with primitive types like
            /// booleans/strings/numbers as well as cross-realm object like `Array`
            /// which can originate from other iframes.
            ///
            /// In general this is intended to be a more robust version of
            /// `is_instance_of`, but if you want strictly the `instanceof` operator
            /// it's recommended to use that instead.
            fn has_type<T>(&self) -> bool
            where
                T: SbCast,
            {
                T::is_type_of(self.as_ref())
            }
            /// Performs a dynamic cast (checked at runtime) of this value into the
            /// target type `T`.
            ///
            /// This method will return `Err(self)` if `self.has_type::<T>()`
            /// returns `false`, and otherwise it will return `Ok(T)` manufactured with
            /// an unchecked cast (verified correct via the `has_type` operation).
            fn dyn_into<T>(self) -> Result<T, Self>
            where
                T: SbCast,
            {
                if self.has_type::<T>() { Ok(self.unchecked_into()) } else { Err(self) }
            }
            /// Performs a dynamic cast (checked at runtime) of this value into the
            /// target type `T`.
            ///
            /// This method will return `None` if `self.has_type::<T>()`
            /// returns `false`, and otherwise it will return `Some(&T)` manufactured
            /// with an unchecked cast (verified correct via the `has_type` operation).
            fn dyn_ref<T>(&self) -> Option<&T>
            where
                T: SbCast,
            {
                if self.has_type::<T>() { Some(self.unchecked_ref()) } else { None }
            }
            /// Performs a zero-cost unchecked cast into the specified type.
            ///
            /// This method will convert the `self` value to the type `T`, where both
            /// `self` and `T` are simple wrappers around `SbValue`. This method **does
            /// not check whether `self` is an instance of `T`**. If used incorrectly
            /// then this method may cause runtime exceptions in both Rust and SB, this
            /// should be used with caution.
            fn unchecked_into<T>(self) -> T
            where
                T: SbCast,
            {
                T::unchecked_from_sb(self.into())
            }
            /// Performs a zero-cost unchecked cast into a reference to the specified
            /// type.
            ///
            /// This method will convert the `self` value to the type `T`, where both
            /// `self` and `T` are simple wrappers around `SbValue`. This method **does
            /// not check whether `self` is an instance of `T`**. If used incorrectly
            /// then this method may cause runtime exceptions in both Rust and SB, this
            /// should be used with caution.
            ///
            /// This method, unlike `unchecked_into`, does not consume ownership of
            /// `self` and instead works over a shared reference.
            fn unchecked_ref<T>(&self) -> &T
            where
                T: SbCast,
            {
                T::unchecked_from_sb_ref(self.as_ref())
            }
            /// Test whether this SB value is an instance of the type `T`.
            ///
            /// This method performs a dynamic check (at runtime) using the SB
            /// `instanceof` operator. This method returns `self instanceof T`.
            ///
            /// Note that `instanceof` does not always work with primitive values or
            /// across different realms (e.g. iframes). If you're not sure whether you
            /// specifically need only `instanceof` it's recommended to use `has_type`
            /// instead.
            fn is_instance_of<T>(&self) -> bool
            where
                T: SbCast,
            {
                T::instanceof(self.as_ref())
            }
            /// Performs a dynamic `instanceof` check to see whether the `SbValue`
            /// provided is an instance of this type.
            ///
            /// This is intended to be an internal implementation detail, you likely
            /// won't need to call this. It's generally called through the
            /// `is_instance_of` method instead.
            fn instanceof(val: &SbValue) -> bool;
            /// Performs a dynamic check to see whether the `SbValue` provided
            /// is a value of this type.
            ///
            /// Unlike `instanceof`, this can be specialised to use a custom check by
            /// adding a `#[wasm_bindgen(is_type_of = callback)]` attribute to the
            /// type import declaration.
            ///
            /// Other than that, this is intended to be an internal implementation
            /// detail of `has_type` and you likely won't need to call this.
            fn is_type_of(val: &SbValue) -> bool {
                Self::instanceof(val)
            }
            /// Performs a zero-cost unchecked conversion from a `SbValue` into an
            /// instance of `Self`
            ///
            /// This is intended to be an internal implementation detail, you likely
            /// won't need to call this.
            fn unchecked_from_sb(val: SbValue) -> Self;
            /// Performs a zero-cost unchecked conversion from a `&SbValue` into an
            /// instance of `&Self`.
            ///
            /// Note the safety of this method, which basically means that `Self` must
            /// be a newtype wrapper around `SbValue`.
            ///
            /// This is intended to be an internal implementation detail, you likely
            /// won't need to call this.
            fn unchecked_from_sb_ref(val: &SbValue) -> &Self;
        }
        /// Trait implemented for wrappers around `SbValue`s generated by `#[wasm_bindgen]`.
        #[doc(hidden)]
        pub trait SbObject: SbCast + WasmDescribe {}
    }
    pub mod closure {
        use crate::{
            convert::{IntoWasmAbi, RefFromWasmAbi, ReturnWasmAbi, WasmAbi, WasmRet},
            describe::*, throw_str, FromWasmAbi, WasmDescribe, WasmSlice,
        };
        use std::mem;
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke0<R: ReturnWasmAbi>(
            a: usize,
            b: usize,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn() -> R = mem::transmute((a, b));
                f()
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke0_mut<R: ReturnWasmAbi>(
            a: usize,
            b: usize,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut() -> R = mem::transmute((a, b));
                f()
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke1<A: FromWasmAbi, R: ReturnWasmAbi>(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                f(A)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke1_mut<A: FromWasmAbi, R: ReturnWasmAbi>(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                f(A)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke2<A: FromWasmAbi, B: FromWasmAbi, R: ReturnWasmAbi>(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                f(A, B)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke2_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                f(A, B)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke3<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B, C) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                f(A, B, C)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke3_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B, C) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                f(A, B, C)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke4<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B, C, D) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                f(A, B, C, D)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke4_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B, C, D) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                f(A, B, C, D)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke5<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B, C, D, E) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                f(A, B, C, D, E)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke5_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B, C, D, E) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                f(A, B, C, D, E)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke6<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
            f1: <F::Abi as WasmAbi>::Prim1,
            f2: <F::Abi as WasmAbi>::Prim2,
            f3: <F::Abi as WasmAbi>::Prim3,
            f4: <F::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B, C, D, E, F) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                f(A, B, C, D, E, F)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke6_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
            f1: <F::Abi as WasmAbi>::Prim1,
            f2: <F::Abi as WasmAbi>::Prim2,
            f3: <F::Abi as WasmAbi>::Prim3,
            f4: <F::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B, C, D, E, F) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                f(A, B, C, D, E, F)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke7<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
            f1: <F::Abi as WasmAbi>::Prim1,
            f2: <F::Abi as WasmAbi>::Prim2,
            f3: <F::Abi as WasmAbi>::Prim3,
            f4: <F::Abi as WasmAbi>::Prim4,
            g1: <G::Abi as WasmAbi>::Prim1,
            g2: <G::Abi as WasmAbi>::Prim2,
            g3: <G::Abi as WasmAbi>::Prim3,
            g4: <G::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B, C, D, E, F, G) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                f(A, B, C, D, E, F, G)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke7_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
            f1: <F::Abi as WasmAbi>::Prim1,
            f2: <F::Abi as WasmAbi>::Prim2,
            f3: <F::Abi as WasmAbi>::Prim3,
            f4: <F::Abi as WasmAbi>::Prim4,
            g1: <G::Abi as WasmAbi>::Prim1,
            g2: <G::Abi as WasmAbi>::Prim2,
            g3: <G::Abi as WasmAbi>::Prim3,
            g4: <G::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B, C, D, E, F, G) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                f(A, B, C, D, E, F, G)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke8<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            H: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
            f1: <F::Abi as WasmAbi>::Prim1,
            f2: <F::Abi as WasmAbi>::Prim2,
            f3: <F::Abi as WasmAbi>::Prim3,
            f4: <F::Abi as WasmAbi>::Prim4,
            g1: <G::Abi as WasmAbi>::Prim1,
            g2: <G::Abi as WasmAbi>::Prim2,
            g3: <G::Abi as WasmAbi>::Prim3,
            g4: <G::Abi as WasmAbi>::Prim4,
            h1: <H::Abi as WasmAbi>::Prim1,
            h2: <H::Abi as WasmAbi>::Prim2,
            h3: <H::Abi as WasmAbi>::Prim3,
            h4: <H::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(A, B, C, D, E, F, G, H) -> R = mem::transmute((a, b));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                let H = <H as FromWasmAbi>::from_abi(H::Abi::join(h1, h2, h3, h4));
                f(A, B, C, D, E, F, G, H)
            };
            ret.return_abi().into()
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke8_mut<
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            H: FromWasmAbi,
            R: ReturnWasmAbi,
        >(
            a: usize,
            b: usize,
            a1: <A::Abi as WasmAbi>::Prim1,
            a2: <A::Abi as WasmAbi>::Prim2,
            a3: <A::Abi as WasmAbi>::Prim3,
            a4: <A::Abi as WasmAbi>::Prim4,
            b1: <B::Abi as WasmAbi>::Prim1,
            b2: <B::Abi as WasmAbi>::Prim2,
            b3: <B::Abi as WasmAbi>::Prim3,
            b4: <B::Abi as WasmAbi>::Prim4,
            c1: <C::Abi as WasmAbi>::Prim1,
            c2: <C::Abi as WasmAbi>::Prim2,
            c3: <C::Abi as WasmAbi>::Prim3,
            c4: <C::Abi as WasmAbi>::Prim4,
            d1: <D::Abi as WasmAbi>::Prim1,
            d2: <D::Abi as WasmAbi>::Prim2,
            d3: <D::Abi as WasmAbi>::Prim3,
            d4: <D::Abi as WasmAbi>::Prim4,
            e1: <E::Abi as WasmAbi>::Prim1,
            e2: <E::Abi as WasmAbi>::Prim2,
            e3: <E::Abi as WasmAbi>::Prim3,
            e4: <E::Abi as WasmAbi>::Prim4,
            f1: <F::Abi as WasmAbi>::Prim1,
            f2: <F::Abi as WasmAbi>::Prim2,
            f3: <F::Abi as WasmAbi>::Prim3,
            f4: <F::Abi as WasmAbi>::Prim4,
            g1: <G::Abi as WasmAbi>::Prim1,
            g2: <G::Abi as WasmAbi>::Prim2,
            g3: <G::Abi as WasmAbi>::Prim3,
            g4: <G::Abi as WasmAbi>::Prim4,
            h1: <H::Abi as WasmAbi>::Prim1,
            h2: <H::Abi as WasmAbi>::Prim2,
            h3: <H::Abi as WasmAbi>::Prim3,
            h4: <H::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(A, B, C, D, E, F, G, H) -> R = mem::transmute((
                    a,
                    b,
                ));
                let A = <A as FromWasmAbi>::from_abi(A::Abi::join(a1, a2, a3, a4));
                let B = <B as FromWasmAbi>::from_abi(B::Abi::join(b1, b2, b3, b4));
                let C = <C as FromWasmAbi>::from_abi(C::Abi::join(c1, c2, c3, c4));
                let D = <D as FromWasmAbi>::from_abi(D::Abi::join(d1, d2, d3, d4));
                let E = <E as FromWasmAbi>::from_abi(E::Abi::join(e1, e2, e3, e4));
                let F = <F as FromWasmAbi>::from_abi(F::Abi::join(f1, f2, f3, f4));
                let G = <G as FromWasmAbi>::from_abi(G::Abi::join(g1, g2, g3, g4));
                let H = <H as FromWasmAbi>::from_abi(H::Abi::join(h1, h2, h3, h4));
                f(A, B, C, D, E, F, G, H)
            };
            ret.return_abi().into()
        }
        impl<'a, 'b, R> IntoWasmAbi for &'a (dyn Fn() -> R + 'b)
        where
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, R> WasmDescribe for dyn Fn() -> R + 'a
        where
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke0::<R> as u32);
                inform(0);
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, R> IntoWasmAbi for &'a mut (dyn FnMut() -> R + 'b)
        where
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, R> WasmDescribe for dyn FnMut() -> R + 'a
        where
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke0_mut::<R> as u32);
                inform(0);
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, R> IntoWasmAbi for &'a (dyn Fn(A) -> R + 'b)
        where
            A: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, R> WasmDescribe for dyn Fn(A) -> R + 'a
        where
            A: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke1::<A, R> as u32);
                inform(1);
                <A as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, R> IntoWasmAbi for &'a mut (dyn FnMut(A) -> R + 'b)
        where
            A: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, R> WasmDescribe for dyn FnMut(A) -> R + 'a
        where
            A: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke1_mut::<A, R> as u32);
                inform(1);
                <A as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, R> IntoWasmAbi for &'a (dyn Fn(A, B) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, R> WasmDescribe for dyn Fn(A, B) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke2::<A, B, R> as u32);
                inform(2);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, R> IntoWasmAbi for &'a mut (dyn FnMut(A, B) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, R> WasmDescribe for dyn FnMut(A, B) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke2_mut::<A, B, R> as u32);
                inform(2);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, R> IntoWasmAbi for &'a (dyn Fn(A, B, C) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, R> WasmDescribe for dyn Fn(A, B, C) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke3::<A, B, C, R> as u32);
                inform(3);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, R> IntoWasmAbi for &'a mut (dyn FnMut(A, B, C) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, R> WasmDescribe for dyn FnMut(A, B, C) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke3_mut::<A, B, C, R> as u32);
                inform(3);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, R> IntoWasmAbi for &'a (dyn Fn(A, B, C, D) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, R> WasmDescribe for dyn Fn(A, B, C, D) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke4::<A, B, C, D, R> as u32);
                inform(4);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, R> IntoWasmAbi
        for &'a mut (dyn FnMut(A, B, C, D) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, R> WasmDescribe for dyn FnMut(A, B, C, D) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke4_mut::<A, B, C, D, R> as u32);
                inform(4);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, R> IntoWasmAbi
        for &'a (dyn Fn(A, B, C, D, E) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, R> WasmDescribe for dyn Fn(A, B, C, D, E) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke5::<A, B, C, D, E, R> as u32);
                inform(5);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, R> IntoWasmAbi
        for &'a mut (dyn FnMut(A, B, C, D, E) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, R> WasmDescribe for dyn FnMut(A, B, C, D, E) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke5_mut::<A, B, C, D, E, R> as u32);
                inform(5);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, F, R> IntoWasmAbi
        for &'a (dyn Fn(A, B, C, D, E, F) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, F, R> WasmDescribe for dyn Fn(A, B, C, D, E, F) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke6::<A, B, C, D, E, F, R> as u32);
                inform(6);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <F as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, F, R> IntoWasmAbi
        for &'a mut (dyn FnMut(A, B, C, D, E, F) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, F, R> WasmDescribe
        for dyn FnMut(A, B, C, D, E, F) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke6_mut::<A, B, C, D, E, F, R> as u32);
                inform(6);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <F as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, F, G, R> IntoWasmAbi
        for &'a (dyn Fn(A, B, C, D, E, F, G) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, F, G, R> WasmDescribe
        for dyn Fn(A, B, C, D, E, F, G) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke7::<A, B, C, D, E, F, G, R> as u32);
                inform(7);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <F as WasmDescribe>::describe();
                <G as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, F, G, R> IntoWasmAbi
        for &'a mut (dyn FnMut(A, B, C, D, E, F, G) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, F, G, R> WasmDescribe
        for dyn FnMut(A, B, C, D, E, F, G) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke7_mut::<A, B, C, D, E, F, G, R> as u32);
                inform(7);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <F as WasmDescribe>::describe();
                <G as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, F, G, H, R> IntoWasmAbi
        for &'a (dyn Fn(A, B, C, D, E, F, G, H) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            H: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, F, G, H, R> WasmDescribe
        for dyn Fn(A, B, C, D, E, F, G, H) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            H: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke8::<A, B, C, D, E, F, G, H, R> as u32);
                inform(8);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <F as WasmDescribe>::describe();
                <G as WasmDescribe>::describe();
                <H as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, B, C, D, E, F, G, H, R> IntoWasmAbi
        for &'a mut (dyn FnMut(A, B, C, D, E, F, G, H) -> R + 'b)
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            H: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        impl<'a, A, B, C, D, E, F, G, H, R> WasmDescribe
        for dyn FnMut(A, B, C, D, E, F, G, H) -> R + 'a
        where
            A: FromWasmAbi,
            B: FromWasmAbi,
            C: FromWasmAbi,
            D: FromWasmAbi,
            E: FromWasmAbi,
            F: FromWasmAbi,
            G: FromWasmAbi,
            H: FromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke8_mut::<A, B, C, D, E, F, G, H, R> as u32);
                inform(8);
                <A as WasmDescribe>::describe();
                <B as WasmDescribe>::describe();
                <C as WasmDescribe>::describe();
                <D as WasmDescribe>::describe();
                <E as WasmDescribe>::describe();
                <F as WasmDescribe>::describe();
                <G as WasmDescribe>::describe();
                <H as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, R> IntoWasmAbi for &'a (dyn Fn(&A) -> R + 'b)
        where
            A: RefFromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke1_ref<A: RefFromWasmAbi, R: ReturnWasmAbi>(
            a: usize,
            b: usize,
            arg1: <A::Abi as WasmAbi>::Prim1,
            arg2: <A::Abi as WasmAbi>::Prim2,
            arg3: <A::Abi as WasmAbi>::Prim3,
            arg4: <A::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked after being dropped");
            }
            let ret = {
                let f: &dyn Fn(&A) -> R = mem::transmute((a, b));
                let arg = <A as RefFromWasmAbi>::ref_from_abi(
                    A::Abi::join(arg1, arg2, arg3, arg4),
                );
                f(&*arg)
            };
            ret.return_abi().into()
        }
        impl<'a, A, R> WasmDescribe for dyn Fn(&A) -> R + 'a
        where
            A: RefFromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke1_ref::<A, R> as u32);
                inform(1);
                <&A as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
        impl<'a, 'b, A, R> IntoWasmAbi for &'a mut (dyn FnMut(&A) -> R + 'b)
        where
            A: RefFromWasmAbi,
            R: ReturnWasmAbi,
        {
            type Abi = WasmSlice;
            fn into_abi(self) -> WasmSlice {
                unsafe {
                    let (a, b): (usize, usize) = mem::transmute(self);
                    WasmSlice {
                        ptr: a as u32,
                        len: b as u32,
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        unsafe extern "C" fn invoke1_mut_ref<A: RefFromWasmAbi, R: ReturnWasmAbi>(
            a: usize,
            b: usize,
            arg1: <A::Abi as WasmAbi>::Prim1,
            arg2: <A::Abi as WasmAbi>::Prim2,
            arg3: <A::Abi as WasmAbi>::Prim3,
            arg4: <A::Abi as WasmAbi>::Prim4,
        ) -> WasmRet<R::Abi> {
            if a == 0 {
                throw_str("closure invoked recursively or after being dropped");
            }
            let ret = {
                let f: &mut dyn FnMut(&A) -> R = mem::transmute((a, b));
                let arg = <A as RefFromWasmAbi>::ref_from_abi(
                    A::Abi::join(arg1, arg2, arg3, arg4),
                );
                f(&*arg)
            };
            ret.return_abi().into()
        }
        impl<'a, A, R> WasmDescribe for dyn FnMut(&A) -> R + 'a
        where
            A: RefFromWasmAbi,
            R: ReturnWasmAbi,
        {
            fn describe() {
                inform(FUNCTION);
                inform(invoke1_mut_ref::<A, R> as u32);
                inform(1);
                <&A as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
                <R as WasmDescribe>::describe();
            }
        }
    }
    pub mod describe {
        #![doc(hidden)]
        use crate::{if_std, SbError, SbValue, __wasm_sb_bindgen_describe};
        use super::cast::SbObject;
        #[inline(always)]
        pub fn inform(a: u32) {
            unsafe { __wasm_sb_bindgen_describe(a) }
        }
        pub const I8: u32 = 0;
        pub const U8: u32 = 0 + 1;
        pub const I16: u32 = 0 + 1 + 1;
        pub const U16: u32 = 0 + 1 + 1 + 1;
        pub const I32: u32 = 0 + 1 + 1 + 1 + 1;
        pub const U32: u32 = 0 + 1 + 1 + 1 + 1 + 1;
        pub const I64: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const U64: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const F32: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const F64: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const BOOLEAN: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const FUNCTION: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const CLOSURE: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const CACHED_STRING: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1;
        pub const STRING: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1;
        pub const REF: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1;
        pub const REFMUT: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1;
        pub const LONGREF: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1;
        pub const SLICE: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1;
        pub const VECTOR: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1;
        pub const EXTERNREF: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const NAMED_EXTERNREF: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const ENUM: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const RUST_STRUCT: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const CHAR: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const OPTIONAL: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const RESULT: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub const UNIT: u32 = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
            + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        pub trait WasmDescribe {
            fn describe();
        }
        /// Trait for element types to implement WasmDescribe for vectors of
        /// themselves.
        pub trait WasmDescribeVector {
            fn describe_vector();
        }
        impl WasmDescribe for i8 {
            fn describe() {
                inform(I8)
            }
        }
        impl WasmDescribe for u8 {
            fn describe() {
                inform(U8)
            }
        }
        impl WasmDescribe for i16 {
            fn describe() {
                inform(I16)
            }
        }
        impl WasmDescribe for u16 {
            fn describe() {
                inform(U16)
            }
        }
        impl WasmDescribe for i32 {
            fn describe() {
                inform(I32)
            }
        }
        impl WasmDescribe for u32 {
            fn describe() {
                inform(U32)
            }
        }
        impl WasmDescribe for i64 {
            fn describe() {
                inform(I64)
            }
        }
        impl WasmDescribe for u64 {
            fn describe() {
                inform(U64)
            }
        }
        impl WasmDescribe for isize {
            fn describe() {
                inform(I32)
            }
        }
        impl WasmDescribe for usize {
            fn describe() {
                inform(U32)
            }
        }
        impl WasmDescribe for f32 {
            fn describe() {
                inform(F32)
            }
        }
        impl WasmDescribe for f64 {
            fn describe() {
                inform(F64)
            }
        }
        impl WasmDescribe for bool {
            fn describe() {
                inform(BOOLEAN)
            }
        }
        impl WasmDescribe for char {
            fn describe() {
                inform(CHAR)
            }
        }
        impl WasmDescribe for str {
            fn describe() {
                inform(STRING)
            }
        }
        impl WasmDescribe for SbValue {
            fn describe() {
                inform(EXTERNREF)
            }
        }
        impl<T> WasmDescribe for *const T {
            fn describe() {
                inform(U32)
            }
        }
        impl<T> WasmDescribe for *mut T {
            fn describe() {
                inform(U32)
            }
        }
        impl<T: WasmDescribe> WasmDescribe for [T] {
            fn describe() {
                inform(SLICE);
                T::describe();
            }
        }
        impl<'a, T: WasmDescribe + ?Sized> WasmDescribe for &'a T {
            fn describe() {
                inform(REF);
                T::describe();
            }
        }
        impl<'a, T: WasmDescribe + ?Sized> WasmDescribe for &'a mut T {
            fn describe() {
                inform(REFMUT);
                T::describe();
            }
        }
        impl WasmDescribe for String {
            fn describe() {
                inform(STRING)
            }
        }
        impl WasmDescribeVector for SbValue {
            fn describe_vector() {
                inform(VECTOR);
                SbValue::describe();
            }
        }
        impl<T: SbObject> WasmDescribeVector for T {
            fn describe_vector() {
                inform(VECTOR);
                T::describe();
            }
        }
        impl<T: WasmDescribeVector> WasmDescribe for Box<[T]> {
            fn describe() {
                T::describe_vector();
            }
        }
        impl<T> WasmDescribe for Vec<T>
        where
            Box<[T]>: WasmDescribe,
        {
            fn describe() {
                <Box<[T]>>::describe();
            }
        }
        impl<T: WasmDescribe> WasmDescribe for Option<T> {
            fn describe() {
                inform(OPTIONAL);
                T::describe();
            }
        }
        impl WasmDescribe for () {
            fn describe() {
                inform(UNIT)
            }
        }
        impl<T: WasmDescribe, E: Into<SbValue>> WasmDescribe for Result<T, E> {
            fn describe() {
                inform(RESULT);
                T::describe();
            }
        }
        impl WasmDescribe for SbError {
            fn describe() {
                SbValue::describe();
            }
        }
    }
    pub mod impls {
        use std::mem::{self, ManuallyDrop};
        use crate::{if_std, SbError, SbValue, UnwrapThrowExt as _};
        use super::{
            FromWasmAbi, IntoWasmAbi, LongRefFromWasmAbi, OptionFromWasmAbi,
            OptionIntoWasmAbi, RefFromWasmAbi, ReturnWasmAbi, TryFromSbValue, WasmAbi,
            WasmPrimitive,
        };
        impl<T: WasmPrimitive> WasmAbi for T {
            type Prim1 = Self;
            type Prim2 = ();
            type Prim3 = ();
            type Prim4 = ();
            #[inline]
            fn split(self) -> (Self, (), (), ()) {
                (self, (), (), ())
            }
            #[inline]
            fn join(prim: Self, _: (), _: (), _: ()) -> Self {
                prim
            }
        }
        impl<T: WasmAbi<Prim4 = ()>> WasmAbi for Option<T> {
            /// Whether this `Option` is a `Some` value.
            type Prim1 = u32;
            type Prim2 = T::Prim1;
            type Prim3 = T::Prim2;
            type Prim4 = T::Prim3;
            #[inline]
            fn split(self) -> (u32, T::Prim1, T::Prim2, T::Prim3) {
                match self {
                    None => {
                        (0, Default::default(), Default::default(), Default::default())
                    }
                    Some(value) => {
                        let (prim1, prim2, prim3, ()) = value.split();
                        (1, prim1, prim2, prim3)
                    }
                }
            }
            #[inline]
            fn join(
                is_some: u32,
                prim1: T::Prim1,
                prim2: T::Prim2,
                prim3: T::Prim3,
            ) -> Self {
                if is_some == 0 { None } else { Some(T::join(prim1, prim2, prim3, ())) }
            }
        }
        impl IntoWasmAbi for i32 {
            type Abi = i32;
            #[inline]
            fn into_abi(self) -> i32 {
                self as i32
            }
        }
        impl FromWasmAbi for i32 {
            type Abi = i32;
            #[inline]
            unsafe fn from_abi(sb: i32) -> Self {
                sb as i32
            }
        }
        impl IntoWasmAbi for Option<i32> {
            type Abi = Option<i32>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as i32)
            }
        }
        impl FromWasmAbi for Option<i32> {
            type Abi = Option<i32>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: i32| v as i32)
            }
        }
        impl IntoWasmAbi for isize {
            type Abi = i32;
            #[inline]
            fn into_abi(self) -> i32 {
                self as i32
            }
        }
        impl FromWasmAbi for isize {
            type Abi = i32;
            #[inline]
            unsafe fn from_abi(sb: i32) -> Self {
                sb as isize
            }
        }
        impl IntoWasmAbi for Option<isize> {
            type Abi = Option<i32>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as i32)
            }
        }
        impl FromWasmAbi for Option<isize> {
            type Abi = Option<i32>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: i32| v as isize)
            }
        }
        impl IntoWasmAbi for u32 {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for u32 {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> Self {
                sb as u32
            }
        }
        impl IntoWasmAbi for Option<u32> {
            type Abi = Option<u32>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as u32)
            }
        }
        impl FromWasmAbi for Option<u32> {
            type Abi = Option<u32>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: u32| v as u32)
            }
        }
        impl IntoWasmAbi for usize {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for usize {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> Self {
                sb as usize
            }
        }
        impl IntoWasmAbi for Option<usize> {
            type Abi = Option<u32>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as u32)
            }
        }
        impl FromWasmAbi for Option<usize> {
            type Abi = Option<u32>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: u32| v as usize)
            }
        }
        impl IntoWasmAbi for i64 {
            type Abi = i64;
            #[inline]
            fn into_abi(self) -> i64 {
                self as i64
            }
        }
        impl FromWasmAbi for i64 {
            type Abi = i64;
            #[inline]
            unsafe fn from_abi(sb: i64) -> Self {
                sb as i64
            }
        }
        impl IntoWasmAbi for Option<i64> {
            type Abi = Option<i64>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as i64)
            }
        }
        impl FromWasmAbi for Option<i64> {
            type Abi = Option<i64>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: i64| v as i64)
            }
        }
        impl IntoWasmAbi for u64 {
            type Abi = u64;
            #[inline]
            fn into_abi(self) -> u64 {
                self as u64
            }
        }
        impl FromWasmAbi for u64 {
            type Abi = u64;
            #[inline]
            unsafe fn from_abi(sb: u64) -> Self {
                sb as u64
            }
        }
        impl IntoWasmAbi for Option<u64> {
            type Abi = Option<u64>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as u64)
            }
        }
        impl FromWasmAbi for Option<u64> {
            type Abi = Option<u64>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: u64| v as u64)
            }
        }
        impl IntoWasmAbi for f32 {
            type Abi = f32;
            #[inline]
            fn into_abi(self) -> f32 {
                self as f32
            }
        }
        impl FromWasmAbi for f32 {
            type Abi = f32;
            #[inline]
            unsafe fn from_abi(sb: f32) -> Self {
                sb as f32
            }
        }
        impl IntoWasmAbi for Option<f32> {
            type Abi = Option<f32>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as f32)
            }
        }
        impl FromWasmAbi for Option<f32> {
            type Abi = Option<f32>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: f32| v as f32)
            }
        }
        impl IntoWasmAbi for f64 {
            type Abi = f64;
            #[inline]
            fn into_abi(self) -> f64 {
                self as f64
            }
        }
        impl FromWasmAbi for f64 {
            type Abi = f64;
            #[inline]
            unsafe fn from_abi(sb: f64) -> Self {
                sb as f64
            }
        }
        impl IntoWasmAbi for Option<f64> {
            type Abi = Option<f64>;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.map(|v| v as f64)
            }
        }
        impl FromWasmAbi for Option<f64> {
            type Abi = Option<f64>;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                sb.map(|v: f64| v as f64)
            }
        }
        impl IntoWasmAbi for i8 {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for i8 {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> Self {
                sb as i8
            }
        }
        impl OptionIntoWasmAbi for i8 {
            #[inline]
            fn none() -> u32 {
                0x00FF_FFFFu32
            }
        }
        impl OptionFromWasmAbi for i8 {
            #[inline]
            fn is_none(sb: &u32) -> bool {
                *sb == 0x00FF_FFFFu32
            }
        }
        impl IntoWasmAbi for u8 {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for u8 {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> Self {
                sb as u8
            }
        }
        impl OptionIntoWasmAbi for u8 {
            #[inline]
            fn none() -> u32 {
                0x00FF_FFFFu32
            }
        }
        impl OptionFromWasmAbi for u8 {
            #[inline]
            fn is_none(sb: &u32) -> bool {
                *sb == 0x00FF_FFFFu32
            }
        }
        impl IntoWasmAbi for i16 {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for i16 {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> Self {
                sb as i16
            }
        }
        impl OptionIntoWasmAbi for i16 {
            #[inline]
            fn none() -> u32 {
                0x00FF_FFFFu32
            }
        }
        impl OptionFromWasmAbi for i16 {
            #[inline]
            fn is_none(sb: &u32) -> bool {
                *sb == 0x00FF_FFFFu32
            }
        }
        impl IntoWasmAbi for u16 {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for u16 {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> Self {
                sb as u16
            }
        }
        impl OptionIntoWasmAbi for u16 {
            #[inline]
            fn none() -> u32 {
                0x00FF_FFFFu32
            }
        }
        impl OptionFromWasmAbi for u16 {
            #[inline]
            fn is_none(sb: &u32) -> bool {
                *sb == 0x00FF_FFFFu32
            }
        }
        impl IntoWasmAbi for bool {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for bool {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> bool {
                sb != 0
            }
        }
        impl OptionIntoWasmAbi for bool {
            #[inline]
            fn none() -> u32 {
                0x00FF_FFFFu32
            }
        }
        impl OptionFromWasmAbi for bool {
            #[inline]
            fn is_none(sb: &u32) -> bool {
                *sb == 0x00FF_FFFFu32
            }
        }
        impl IntoWasmAbi for char {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl FromWasmAbi for char {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> char {
                char::from_u32_unchecked(sb)
            }
        }
        impl OptionIntoWasmAbi for char {
            #[inline]
            fn none() -> u32 {
                0x00FF_FFFFu32
            }
        }
        impl OptionFromWasmAbi for char {
            #[inline]
            fn is_none(sb: &u32) -> bool {
                *sb == 0x00FF_FFFFu32
            }
        }
        impl<T> IntoWasmAbi for *const T {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl<T> FromWasmAbi for *const T {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> *const T {
                sb as *const T
            }
        }
        impl<T> IntoWasmAbi for *mut T {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self as u32
            }
        }
        impl<T> FromWasmAbi for *mut T {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> *mut T {
                sb as *mut T
            }
        }
        impl IntoWasmAbi for SbValue {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                let ret = self.idx;
                mem::forget(self);
                ret
            }
        }
        impl FromWasmAbi for SbValue {
            type Abi = u32;
            #[inline]
            unsafe fn from_abi(sb: u32) -> SbValue {
                SbValue::_new(sb)
            }
        }
        impl<'a> IntoWasmAbi for &'a SbValue {
            type Abi = u32;
            #[inline]
            fn into_abi(self) -> u32 {
                self.idx
            }
        }
        impl RefFromWasmAbi for SbValue {
            type Abi = u32;
            type Anchor = ManuallyDrop<SbValue>;
            #[inline]
            unsafe fn ref_from_abi(sb: u32) -> Self::Anchor {
                ManuallyDrop::new(SbValue::_new(sb))
            }
        }
        impl LongRefFromWasmAbi for SbValue {
            type Abi = u32;
            type Anchor = SbValue;
            #[inline]
            unsafe fn long_ref_from_abi(sb: u32) -> Self::Anchor {
                Self::from_abi(sb)
            }
        }
        impl<T: OptionIntoWasmAbi> IntoWasmAbi for Option<T> {
            type Abi = T::Abi;
            #[inline]
            fn into_abi(self) -> T::Abi {
                match self {
                    None => T::none(),
                    Some(me) => me.into_abi(),
                }
            }
        }
        impl<T: OptionFromWasmAbi> FromWasmAbi for Option<T> {
            type Abi = T::Abi;
            #[inline]
            unsafe fn from_abi(sb: T::Abi) -> Self {
                if T::is_none(&sb) { None } else { Some(T::from_abi(sb)) }
            }
        }
        impl IntoWasmAbi for () {
            type Abi = ();
            #[inline]
            fn into_abi(self) {
                self
            }
        }
        impl<T: WasmAbi<Prim3 = (), Prim4 = ()>> WasmAbi for Result<T, u32> {
            type Prim1 = T::Prim1;
            type Prim2 = T::Prim2;
            /// If this `Result` is an `Err`, the error value.
            type Prim3 = u32;
            /// Whether this `Result` is an `Err`.
            type Prim4 = u32;
            #[inline]
            fn split(self) -> (T::Prim1, T::Prim2, u32, u32) {
                match self {
                    Ok(value) => {
                        let (prim1, prim2, (), ()) = value.split();
                        (prim1, prim2, 0, 0)
                    }
                    Err(err) => (Default::default(), Default::default(), err, 1),
                }
            }
            #[inline]
            fn join(prim1: T::Prim1, prim2: T::Prim2, err: u32, is_err: u32) -> Self {
                if is_err == 0 { Ok(T::join(prim1, prim2, (), ())) } else { Err(err) }
            }
        }
        impl<T, E> ReturnWasmAbi for Result<T, E>
        where
            T: IntoWasmAbi,
            E: Into<SbValue>,
            T::Abi: WasmAbi<Prim3 = (), Prim4 = ()>,
        {
            type Abi = Result<T::Abi, u32>;
            #[inline]
            fn return_abi(self) -> Self::Abi {
                match self {
                    Ok(v) => Ok(v.into_abi()),
                    Err(e) => {
                        let sbval = e.into();
                        Err(sbval.into_abi())
                    }
                }
            }
        }
        impl IntoWasmAbi for SbError {
            type Abi = <SbValue as IntoWasmAbi>::Abi;
            fn into_abi(self) -> Self::Abi {
                self.value.into_abi()
            }
        }
        use std::fmt::Debug;
        pub fn sb_value_vector_into_abi<T: Into<SbValue>>(
            vector: Box<[T]>,
        ) -> <Box<[SbValue]> as IntoWasmAbi>::Abi {
            let sb_vals: Box<[SbValue]> = vector
                .into_vec()
                .into_iter()
                .map(|x| x.into())
                .collect();
            sb_vals.into_abi()
        }
        pub unsafe fn sb_value_vector_from_abi<T: TryFromSbValue>(
            sb: <Box<[SbValue]> as FromWasmAbi>::Abi,
        ) -> Box<[T]>
        where
            T::Error: Debug,
        {
            let sb_vals = <Vec<SbValue> as FromWasmAbi>::from_abi(sb);
            let mut result = Vec::with_capacity(sb_vals.len());
            for value in sb_vals {
                result
                    .push(
                        T::try_from_sb_value(value)
                            .expect_throw("array contains a value of the wrong type"),
                    );
            }
            result.into_boxed_slice()
        }
    }
    pub mod slices {
        use std::{mem, ops::{Deref, DerefMut}};
        use crate::{__wasm_sb_bindgen_copy_to_typed_array, if_std};
        use super::{
            cast::SbObject, describe::{inform, WasmDescribeVector, *},
            impls::{sb_value_vector_from_abi, sb_value_vector_into_abi},
            FromWasmAbi, IntoWasmAbi, LongRefFromWasmAbi, OptionFromWasmAbi,
            OptionIntoWasmAbi, RefFromWasmAbi, RefMutFromWasmAbi, VectorFromWasmAbi,
            VectorIntoWasmAbi, WasmAbi,
        };
        use crate::SbValue;
        #[repr(C)]
        pub struct WasmSlice {
            pub ptr: u32,
            pub len: u32,
        }
        impl WasmAbi for WasmSlice {
            /// `self.ptr`
            type Prim1 = u32;
            /// `self.len`
            type Prim2 = u32;
            type Prim3 = ();
            type Prim4 = ();
            #[inline]
            fn split(self) -> (u32, u32, (), ()) {
                (self.ptr, self.len, (), ())
            }
            #[inline]
            fn join(ptr: u32, len: u32, _: (), _: ()) -> Self {
                Self { ptr, len }
            }
        }
        #[inline]
        fn null_slice() -> WasmSlice {
            WasmSlice { ptr: 0, len: 0 }
        }
        pub struct WasmMutSlice {
            pub slice: WasmSlice,
            pub idx: u32,
        }
        impl WasmAbi for WasmMutSlice {
            /// `self.slice.ptr`
            type Prim1 = u32;
            /// `self.slice.len`
            type Prim2 = u32;
            /// `self.idx`
            type Prim3 = u32;
            type Prim4 = ();
            #[inline]
            fn split(self) -> (u32, u32, u32, ()) {
                (self.slice.ptr, self.slice.len, self.idx, ())
            }
            #[inline]
            fn join(ptr: u32, len: u32, idx: u32, _: ()) -> Self {
                Self {
                    slice: WasmSlice { ptr, len },
                    idx,
                }
            }
        }
        /// The representation of a mutable slice passed from Sb to Rust.
        pub struct MutSlice<T> {
            /// A copy of the data in the Sb typed array.
            contents: Box<[T]>,
            /// A reference to the original Sb typed array.
            sb: SbValue,
        }
        impl<T> Drop for MutSlice<T> {
            fn drop(&mut self) {
                unsafe {
                    __wasm_sb_bindgen_copy_to_typed_array(
                        self.contents.as_ptr() as *const u8,
                        self.contents.len() * mem::size_of::<T>(),
                        self.sb.idx,
                    );
                }
            }
        }
        impl<T> Deref for MutSlice<T> {
            type Target = [T];
            fn deref(&self) -> &[T] {
                &self.contents
            }
        }
        impl<T> DerefMut for MutSlice<T> {
            fn deref_mut(&mut self) -> &mut [T] {
                &mut self.contents
            }
        }
        impl WasmDescribeVector for u8 {
            fn describe_vector() {
                inform(VECTOR);
                u8::describe();
            }
        }
        impl VectorIntoWasmAbi for u8 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[u8]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for u8 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[u8]> {
                let ptr = <*mut u8>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [u8] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [u8] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [u8] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [u8] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [u8] {
            type Abi = WasmSlice;
            type Anchor = Box<[u8]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[u8]> {
                <Box<[u8]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [u8] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<u8>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<u8> {
                let contents = <Box<[u8]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [u8] {
            type Abi = WasmSlice;
            type Anchor = Box<[u8]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[u8]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for i8 {
            fn describe_vector() {
                inform(VECTOR);
                i8::describe();
            }
        }
        impl VectorIntoWasmAbi for i8 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[i8]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for i8 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[i8]> {
                let ptr = <*mut i8>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [i8] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [i8] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [i8] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [i8] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [i8] {
            type Abi = WasmSlice;
            type Anchor = Box<[i8]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[i8]> {
                <Box<[i8]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [i8] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<i8>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<i8> {
                let contents = <Box<[i8]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [i8] {
            type Abi = WasmSlice;
            type Anchor = Box<[i8]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[i8]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for u16 {
            fn describe_vector() {
                inform(VECTOR);
                u16::describe();
            }
        }
        impl VectorIntoWasmAbi for u16 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[u16]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for u16 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[u16]> {
                let ptr = <*mut u16>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [u16] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [u16] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [u16] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [u16] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [u16] {
            type Abi = WasmSlice;
            type Anchor = Box<[u16]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[u16]> {
                <Box<[u16]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [u16] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<u16>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<u16> {
                let contents = <Box<[u16]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [u16] {
            type Abi = WasmSlice;
            type Anchor = Box<[u16]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[u16]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for i16 {
            fn describe_vector() {
                inform(VECTOR);
                i16::describe();
            }
        }
        impl VectorIntoWasmAbi for i16 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[i16]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for i16 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[i16]> {
                let ptr = <*mut i16>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [i16] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [i16] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [i16] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [i16] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [i16] {
            type Abi = WasmSlice;
            type Anchor = Box<[i16]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[i16]> {
                <Box<[i16]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [i16] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<i16>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<i16> {
                let contents = <Box<[i16]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [i16] {
            type Abi = WasmSlice;
            type Anchor = Box<[i16]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[i16]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for u32 {
            fn describe_vector() {
                inform(VECTOR);
                u32::describe();
            }
        }
        impl VectorIntoWasmAbi for u32 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[u32]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for u32 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[u32]> {
                let ptr = <*mut u32>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [u32] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [u32] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [u32] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [u32] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [u32] {
            type Abi = WasmSlice;
            type Anchor = Box<[u32]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[u32]> {
                <Box<[u32]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [u32] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<u32>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<u32> {
                let contents = <Box<[u32]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [u32] {
            type Abi = WasmSlice;
            type Anchor = Box<[u32]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[u32]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for i32 {
            fn describe_vector() {
                inform(VECTOR);
                i32::describe();
            }
        }
        impl VectorIntoWasmAbi for i32 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[i32]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for i32 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[i32]> {
                let ptr = <*mut i32>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [i32] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [i32] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [i32] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [i32] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [i32] {
            type Abi = WasmSlice;
            type Anchor = Box<[i32]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[i32]> {
                <Box<[i32]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [i32] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<i32>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<i32> {
                let contents = <Box<[i32]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [i32] {
            type Abi = WasmSlice;
            type Anchor = Box<[i32]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[i32]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for u64 {
            fn describe_vector() {
                inform(VECTOR);
                u64::describe();
            }
        }
        impl VectorIntoWasmAbi for u64 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[u64]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for u64 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[u64]> {
                let ptr = <*mut u64>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [u64] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [u64] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [u64] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [u64] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [u64] {
            type Abi = WasmSlice;
            type Anchor = Box<[u64]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[u64]> {
                <Box<[u64]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [u64] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<u64>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<u64> {
                let contents = <Box<[u64]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [u64] {
            type Abi = WasmSlice;
            type Anchor = Box<[u64]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[u64]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for i64 {
            fn describe_vector() {
                inform(VECTOR);
                i64::describe();
            }
        }
        impl VectorIntoWasmAbi for i64 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[i64]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for i64 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[i64]> {
                let ptr = <*mut i64>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [i64] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [i64] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [i64] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [i64] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [i64] {
            type Abi = WasmSlice;
            type Anchor = Box<[i64]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[i64]> {
                <Box<[i64]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [i64] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<i64>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<i64> {
                let contents = <Box<[i64]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [i64] {
            type Abi = WasmSlice;
            type Anchor = Box<[i64]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[i64]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for usize {
            fn describe_vector() {
                inform(VECTOR);
                usize::describe();
            }
        }
        impl VectorIntoWasmAbi for usize {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[usize]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for usize {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[usize]> {
                let ptr = <*mut usize>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [usize] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [usize] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [usize] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [usize] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [usize] {
            type Abi = WasmSlice;
            type Anchor = Box<[usize]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[usize]> {
                <Box<[usize]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [usize] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<usize>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<usize> {
                let contents = <Box<[usize]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [usize] {
            type Abi = WasmSlice;
            type Anchor = Box<[usize]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[usize]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for isize {
            fn describe_vector() {
                inform(VECTOR);
                isize::describe();
            }
        }
        impl VectorIntoWasmAbi for isize {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[isize]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for isize {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[isize]> {
                let ptr = <*mut isize>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [isize] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [isize] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [isize] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [isize] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [isize] {
            type Abi = WasmSlice;
            type Anchor = Box<[isize]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[isize]> {
                <Box<[isize]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [isize] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<isize>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<isize> {
                let contents = <Box<[isize]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [isize] {
            type Abi = WasmSlice;
            type Anchor = Box<[isize]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[isize]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for f32 {
            fn describe_vector() {
                inform(VECTOR);
                f32::describe();
            }
        }
        impl VectorIntoWasmAbi for f32 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[f32]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for f32 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[f32]> {
                let ptr = <*mut f32>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [f32] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [f32] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [f32] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [f32] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [f32] {
            type Abi = WasmSlice;
            type Anchor = Box<[f32]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[f32]> {
                <Box<[f32]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [f32] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<f32>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<f32> {
                let contents = <Box<[f32]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [f32] {
            type Abi = WasmSlice;
            type Anchor = Box<[f32]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[f32]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for f64 {
            fn describe_vector() {
                inform(VECTOR);
                f64::describe();
            }
        }
        impl VectorIntoWasmAbi for f64 {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[f64]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for f64 {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[f64]> {
                let ptr = <*mut f64>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a [f64] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                WasmSlice {
                    ptr: self.as_ptr().into_abi(),
                    len: self.len() as u32,
                }
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a [f64] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<'a> IntoWasmAbi for &'a mut [f64] {
            type Abi = WasmSlice;
            #[inline]
            fn into_abi(self) -> WasmSlice {
                (&*self).into_abi()
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a mut [f64] {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl RefFromWasmAbi for [f64] {
            type Abi = WasmSlice;
            type Anchor = Box<[f64]>;
            #[inline]
            unsafe fn ref_from_abi(sb: WasmSlice) -> Box<[f64]> {
                <Box<[f64]>>::from_abi(sb)
            }
        }
        impl RefMutFromWasmAbi for [f64] {
            type Abi = WasmMutSlice;
            type Anchor = MutSlice<f64>;
            #[inline]
            unsafe fn ref_mut_from_abi(sb: WasmMutSlice) -> MutSlice<f64> {
                let contents = <Box<[f64]>>::from_abi(sb.slice);
                let sb = SbValue::from_abi(sb.idx);
                MutSlice { contents, sb }
            }
        }
        impl LongRefFromWasmAbi for [f64] {
            type Abi = WasmSlice;
            type Anchor = Box<[f64]>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: WasmSlice) -> Box<[f64]> {
                Self::ref_from_abi(sb)
            }
        }
        impl WasmDescribeVector for String {
            fn describe_vector() {
                inform(VECTOR);
                inform(NAMED_EXTERNREF);
                inform(6);
                inform('s' as u32);
                inform('t' as u32);
                inform('r' as u32);
                inform('i' as u32);
                inform('n' as u32);
                inform('g' as u32);
            }
        }
        impl VectorIntoWasmAbi for String {
            type Abi = <Box<[SbValue]> as IntoWasmAbi>::Abi;
            fn vector_into_abi(vector: Box<[Self]>) -> Self::Abi {
                sb_value_vector_into_abi(vector)
            }
        }
        impl VectorFromWasmAbi for String {
            type Abi = <Box<[SbValue]> as FromWasmAbi>::Abi;
            unsafe fn vector_from_abi(sb: Self::Abi) -> Box<[Self]> {
                sb_value_vector_from_abi(sb)
            }
        }
        #[inline]
        fn unsafe_get_cached_str(_x: &str) -> Option<WasmSlice> {
            None
        }
        impl<T> IntoWasmAbi for Vec<T>
        where
            Box<[T]>: IntoWasmAbi<Abi = WasmSlice>,
        {
            type Abi = <Box<[T]> as IntoWasmAbi>::Abi;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                self.into_boxed_slice().into_abi()
            }
        }
        impl<T> OptionIntoWasmAbi for Vec<T>
        where
            Box<[T]>: IntoWasmAbi<Abi = WasmSlice>,
        {
            #[inline]
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<T> FromWasmAbi for Vec<T>
        where
            Box<[T]>: FromWasmAbi<Abi = WasmSlice>,
        {
            type Abi = <Box<[T]> as FromWasmAbi>::Abi;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                <Box<[T]>>::from_abi(sb).into()
            }
        }
        impl<T> OptionFromWasmAbi for Vec<T>
        where
            Box<[T]>: FromWasmAbi<Abi = WasmSlice>,
        {
            #[inline]
            fn is_none(abi: &WasmSlice) -> bool {
                abi.ptr == 0
            }
        }
        impl IntoWasmAbi for String {
            type Abi = <Vec<u8> as IntoWasmAbi>::Abi;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                unsafe_get_cached_str(&self)
                    .unwrap_or_else(|| self.into_bytes().into_abi())
            }
        }
        impl OptionIntoWasmAbi for String {
            #[inline]
            fn none() -> Self::Abi {
                null_slice()
            }
        }
        impl FromWasmAbi for String {
            type Abi = <Vec<u8> as FromWasmAbi>::Abi;
            #[inline]
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                String::from_utf8_unchecked(<Vec<u8>>::from_abi(sb))
            }
        }
        impl OptionFromWasmAbi for String {
            #[inline]
            fn is_none(slice: &WasmSlice) -> bool {
                slice.ptr == 0
            }
        }
        impl<'a> IntoWasmAbi for &'a str {
            type Abi = <&'a [u8] as IntoWasmAbi>::Abi;
            #[inline]
            fn into_abi(self) -> Self::Abi {
                unsafe_get_cached_str(self).unwrap_or_else(|| self.as_bytes().into_abi())
            }
        }
        impl<'a> OptionIntoWasmAbi for &'a str {
            #[inline]
            fn none() -> Self::Abi {
                null_slice()
            }
        }
        impl RefFromWasmAbi for str {
            type Abi = <[u8] as RefFromWasmAbi>::Abi;
            type Anchor = Box<str>;
            #[inline]
            unsafe fn ref_from_abi(sb: Self::Abi) -> Self::Anchor {
                mem::transmute::<Box<[u8]>, Box<str>>(<Box<[u8]>>::from_abi(sb))
            }
        }
        impl LongRefFromWasmAbi for str {
            type Abi = <[u8] as RefFromWasmAbi>::Abi;
            type Anchor = Box<str>;
            #[inline]
            unsafe fn long_ref_from_abi(sb: Self::Abi) -> Self::Anchor {
                Self::ref_from_abi(sb)
            }
        }
        impl<T: VectorIntoWasmAbi> IntoWasmAbi for Box<[T]> {
            type Abi = <T as VectorIntoWasmAbi>::Abi;
            fn into_abi(self) -> Self::Abi {
                T::vector_into_abi(self)
            }
        }
        impl<T> OptionIntoWasmAbi for Box<[T]>
        where
            Self: IntoWasmAbi<Abi = WasmSlice>,
        {
            fn none() -> WasmSlice {
                null_slice()
            }
        }
        impl<T: VectorFromWasmAbi> FromWasmAbi for Box<[T]> {
            type Abi = <T as VectorFromWasmAbi>::Abi;
            unsafe fn from_abi(sb: Self::Abi) -> Self {
                T::vector_from_abi(sb)
            }
        }
        impl<T> OptionFromWasmAbi for Box<[T]>
        where
            Self: FromWasmAbi<Abi = WasmSlice>,
        {
            fn is_none(slice: &WasmSlice) -> bool {
                slice.ptr == 0
            }
        }
        impl VectorIntoWasmAbi for SbValue {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[Self]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl VectorFromWasmAbi for SbValue {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[Self]> {
                let ptr = <*mut SbValue>::from_abi(sb.ptr);
                let len = sb.len as usize;
                Vec::from_raw_parts(ptr, len, len).into_boxed_slice()
            }
        }
        impl<T> VectorIntoWasmAbi for T
        where
            T: SbObject,
        {
            type Abi = WasmSlice;
            #[inline]
            fn vector_into_abi(vector: Box<[T]>) -> WasmSlice {
                let ptr = vector.as_ptr();
                let len = vector.len();
                mem::forget(vector);
                WasmSlice {
                    ptr: ptr.into_abi(),
                    len: len as u32,
                }
            }
        }
        impl<T> VectorFromWasmAbi for T
        where
            T: SbObject,
        {
            type Abi = WasmSlice;
            #[inline]
            unsafe fn vector_from_abi(sb: WasmSlice) -> Box<[T]> {
                let ptr = <*mut SbValue>::from_abi(sb.ptr);
                let len = sb.len as usize;
                let vec: Vec<T> = Vec::from_raw_parts(ptr, len, len)
                    .drain(..)
                    .map(|sb_value| T::unchecked_from_sb(sb_value))
                    .collect();
                vec.into_boxed_slice()
            }
        }
    }
    pub mod traits {
        use std::{borrow::Borrow, ops::{Deref, DerefMut}};
        use crate::WasmDescribe;
        use crate::{if_std, SbValue};
        pub trait IntoWasmAbi: WasmDescribe {
            /// The wasm ABI type that this converts into when crossing the ABI
            /// boundary.
            type Abi: WasmAbi;
            /// Convert `self` into `Self::Abi` so that it can be sent across the wasm
            /// ABI boundary.
            fn into_abi(self) -> Self::Abi;
        }
        pub trait FromWasmAbi: WasmDescribe {
            /// The wasm ABI type that this converts from when coming back out from the
            /// ABI boundary.
            type Abi: WasmAbi;
            /// Recover a `Self` from `Self::Abi`.
            ///
            /// # Safety
            ///
            /// This is only safe to call when -- and implementations may assume that --
            /// the supplied `Self::Abi` was previously generated by a call to `<Self as
            /// IntoWasmAbi>::into_abi()` or the moral equivalent in JS.
            unsafe fn from_abi(sb: Self::Abi) -> Self;
        }
        pub trait RefFromWasmAbi: WasmDescribe {
            /// The wasm ABI type references to `Self` are recovered from.
            type Abi: WasmAbi;
            /// The type that holds the reference to `Self` for the duration of the
            /// invocation of the function that has an `&Self` parameter. This is
            /// required to ensure that the lifetimes don't persist beyond one function
            /// call, and so that they remain anonymous.
            type Anchor: Deref<Target = Self>;
            /// Recover a `Self::Anchor` from `Self::Abi`.
            ///
            /// # Safety
            ///
            /// Same as `FromWasmAbi::from_abi`.
            unsafe fn ref_from_abi(sb: Self::Abi) -> Self::Anchor;
        }
        pub trait LongRefFromWasmAbi: WasmDescribe {
            /// Same as `RefFromWasmAbi::Abi`
            type Abi: WasmAbi;
            /// Same as `RefFromWasmAbi::Anchor`
            type Anchor: Borrow<Self>;
            /// Same as `RefFromWasmAbi::ref_from_abi`
            unsafe fn long_ref_from_abi(sb: Self::Abi) -> Self::Anchor;
        }
        pub trait RefMutFromWasmAbi: WasmDescribe {
            /// Same as `RefFromWasmAbi::Abi`
            type Abi: WasmAbi;
            /// Same as `RefFromWasmAbi::Anchor`
            type Anchor: DerefMut<Target = Self>;
            /// Same as `RefFromWasmAbi::ref_from_abi`
            unsafe fn ref_mut_from_abi(sb: Self::Abi) -> Self::Anchor;
        }
        pub trait OptionIntoWasmAbi: IntoWasmAbi {
            /// Returns an ABI instance indicating "none", which JS will interpret as
            /// the `None` branch of this option.
            ///
            /// It should be guaranteed that the `IntoWasmAbi` can never produce the ABI
            /// value returned here.
            fn none() -> Self::Abi;
        }
        pub trait OptionFromWasmAbi: FromWasmAbi {
            /// Tests whether the argument is a "none" instance. If so it will be
            /// deserialized as `None`, and otherwise it will be passed to
            /// `FromWasmAbi`.
            fn is_none(abi: &Self::Abi) -> bool;
        }
        pub unsafe trait WasmPrimitive: Default {}
        unsafe impl WasmPrimitive for u32 {}
        unsafe impl WasmPrimitive for i32 {}
        unsafe impl WasmPrimitive for u64 {}
        unsafe impl WasmPrimitive for i64 {}
        unsafe impl WasmPrimitive for f32 {}
        unsafe impl WasmPrimitive for f64 {}
        unsafe impl WasmPrimitive for () {}
        pub trait WasmAbi {
            type Prim1: WasmPrimitive;
            type Prim2: WasmPrimitive;
            type Prim3: WasmPrimitive;
            type Prim4: WasmPrimitive;
            /// Splits this type up into primitives to be sent over the ABI.
            fn split(self) -> (Self::Prim1, Self::Prim2, Self::Prim3, Self::Prim4);
            /// Reconstructs this type from primitives received over the ABI.
            fn join(
                prim1: Self::Prim1,
                prim2: Self::Prim2,
                prim3: Self::Prim3,
                prim4: Self::Prim4,
            ) -> Self;
        }
        pub trait ReturnWasmAbi: WasmDescribe {
            /// Same as `IntoWasmAbi::Abi`
            type Abi: WasmAbi;
            /// Same as `IntoWasmAbi::into_abi`, except that it may throw and never
            /// return in the case of `Err`.
            fn return_abi(self) -> Self::Abi;
        }
        impl<T: IntoWasmAbi> ReturnWasmAbi for T {
            type Abi = T::Abi;
            #[inline]
            fn return_abi(self) -> Self::Abi {
                self.into_abi()
            }
        }
        use core::marker::Sized;
        use std::boxed::Box;
        use super::describe::WasmDescribeVector;
        /// Trait for element types to implement IntoWasmAbi for vectors of
        /// themselves.
        pub trait VectorIntoWasmAbi: WasmDescribeVector + Sized {
            type Abi: WasmAbi;
            fn vector_into_abi(vector: Box<[Self]>) -> Self::Abi;
        }
        /// Trait for element types to implement FromWasmAbi for vectors of
        /// themselves.
        pub trait VectorFromWasmAbi: WasmDescribeVector + Sized {
            type Abi: WasmAbi;
            unsafe fn vector_from_abi(sb: Self::Abi) -> Box<[Self]>;
        }
        #[repr(C)]
        pub struct WasmRet<T: WasmAbi> {
            prim1: T::Prim1,
            prim2: T::Prim2,
            prim3: T::Prim3,
            prim4: T::Prim4,
        }
        impl<T: WasmAbi> From<T> for WasmRet<T> {
            fn from(value: T) -> Self {
                let (prim1, prim2, prim3, prim4) = value.split();
                Self { prim1, prim2, prim3, prim4 }
            }
        }
        impl<T: WasmAbi> WasmRet<T> {
            /// Joins the components of this `WasmRet` back into the type they represent.
            pub fn join(self) -> T {
                T::join(self.prim1, self.prim2, self.prim3, self.prim4)
            }
        }
        pub trait TryFromSbValue: Sized {
            /// The type returned in the event of a conversion error.
            type Error;
            /// Performs the conversion.
            fn try_from_sb_value(value: SbValue) -> Result<Self, Self::Error>;
        }
    }
    pub use describe::WasmDescribe;
    pub use traits::*;
}
pub mod externref {
    use std::{cell::Cell, cmp::max, slice};
    use crate::{externs, SbValue};
    #[cfg(
        all(
            target_arch = "wasm32",
            not(any(target_os = "emscripten", target_os = "wasi"))
        )
    )]
    #[link(wasm_import_module = "__wbindgen_externref_xform__")]
    extern "C" {
        fn __wbindgen_externref_table_grow(delta: usize) -> i32;
        fn __wbindgen_externref_table_set_null(idx: usize) -> ();
    }
    pub struct Slab {
        data: Vec<usize>,
        head: usize,
        base: usize,
    }
    impl Slab {
        fn new() -> Slab {
            Slab {
                data: Vec::new(),
                head: 0,
                base: 0,
            }
        }
        fn alloc(&mut self) -> usize {
            let ret = self.head;
            if ret == self.data.len() {
                let curr_len = self.data.len();
                if curr_len == self.data.capacity() {
                    let extra = max(128, curr_len);
                    let r = unsafe { __wbindgen_externref_table_grow(extra) };
                    if r == -1 {
                        internal_error("table grow failure")
                    }
                    if self.base == 0 {
                        self.base = r as usize;
                    } else if self.base + self.data.len() != r as usize {
                        internal_error("someone else allocated table entries?")
                    }
                    if self.data.try_reserve_exact(extra).is_err() {
                        internal_error("allocation failure");
                    }
                }
                if self.data.len() >= self.data.capacity() {
                    internal_error("push should be infallible now")
                }
                self.data.push(ret + 1);
            }
            match self.data.get_mut(ret) {
                Some(slot) => self.head = *slot,
                None => internal_error("ret out of bounds"),
            }
            ret + self.base
        }
        fn dealloc(&mut self, slot: usize) {
            if slot < self.base {
                internal_error("free reserved slot");
            }
            let slot = slot - self.base;
            match self.data.get_mut(slot) {
                Some(ptr) => {
                    *ptr = self.head;
                    self.head = slot;
                }
                None => internal_error("slot out of bounds"),
            }
        }
        fn live_count(&self) -> u32 {
            let mut free_count = 0;
            let mut next = self.head;
            while next < self.data.len() {
                if true {
                    if !((free_count as usize) < self.data.len()) {
                        ::core::panicking::panic(
                            "assertion failed: (free_count as usize) < self.data.len()",
                        )
                    }
                }
                free_count += 1;
                match self.data.get(next) {
                    Some(n) => next = *n,
                    None => internal_error("slot out of bounds"),
                };
            }
            self.data.len() as u32 - free_count
        }
    }
    fn internal_error(msg: &str) -> ! {
        if true { super::throw_str(msg) } else { std::process::abort() }
    }
    pub const HEAP_SLAB: ::std::thread::LocalKey<Cell<Slab>> = {
        #[inline]
        fn __init() -> Cell<Slab> {
            Cell::new(Slab::new())
        }
        #[inline]
        unsafe fn __getit(
            init: ::std::option::Option<&mut ::std::option::Option<Cell<Slab>>>,
        ) -> ::std::option::Option<&'static Cell<Slab>> {
            static __KEY: ::std::thread::local_impl::Key<Cell<Slab>> = ::std::thread::local_impl::Key::new();
            unsafe {
                __KEY
                    .get(move || {
                        if let ::std::option::Option::Some(init) = init {
                            if let ::std::option::Option::Some(value) = init.take() {
                                return value;
                            } else if true {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "internal error: entered unreachable code: {0}",
                                            format_args!("missing default value"),
                                        ),
                                    );
                                };
                            }
                        }
                        __init()
                    })
            }
        }
        unsafe { ::std::thread::LocalKey::new(__getit) }
    };
    #[no_mangle]
    pub extern "C" fn __externref_table_alloc() -> usize {
        HEAP_SLAB
            .try_with(|slot| {
                let mut slab = slot.replace(Slab::new());
                let ret = slab.alloc();
                slot.replace(slab);
                ret
            })
            .unwrap_or_else(|_| internal_error("tls access failure"))
    }
    #[no_mangle]
    pub extern "C" fn __externref_table_dealloc(idx: usize) {
        if idx < super::SBIDX_RESERVED as usize {
            return;
        }
        unsafe {
            __wbindgen_externref_table_set_null(idx);
        }
        HEAP_SLAB
            .try_with(|slot| {
                let mut slab = slot.replace(Slab::new());
                slab.dealloc(idx);
                slot.replace(slab);
            })
            .unwrap_or_else(|_| internal_error("tls access failure"))
    }
    #[no_mangle]
    pub unsafe extern "C" fn __externref_drop_slice(ptr: *mut SbValue, len: usize) {
        for slot in slice::from_raw_parts_mut(ptr, len) {
            __externref_table_dealloc(slot.idx as usize);
        }
    }
    #[no_mangle]
    pub unsafe extern "C" fn __externref_heap_live_count() -> u32 {
        HEAP_SLAB
            .try_with(|slot| {
                let slab = slot.replace(Slab::new());
                let count = slab.live_count();
                slot.replace(slab);
                count
            })
            .unwrap_or_else(|_| internal_error("tls access failure"))
    }
    #[inline(never)]
    pub fn link_intrinsics() {}
}
use crate::convert::{slices::WasmSlice, WasmRet};
pub use convert::describe;
pub use convert::WasmDescribe;
use convert::{cast::SbCast, FromWasmAbi, TryFromSbValue};
use std::{
    fmt, marker, mem,
    ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Neg, Not, Rem, Shl, Shr, Sub},
};
pub use wasm_sb_bindgen_macro::wasm_sb_bindgen;
pub struct SbValue {
    pub(crate) idx: u32,
    _marker: marker::PhantomData<*mut u8>,
}
const SBIDX_OFFSET: u32 = 128;
const SBIDX_UNDEFINED: u32 = SBIDX_OFFSET;
const SBIDX_NULL: u32 = SBIDX_OFFSET + 1;
const SBIDX_TRUE: u32 = SBIDX_OFFSET + 2;
const SBIDX_FALSE: u32 = SBIDX_OFFSET + 3;
const SBIDX_RESERVED: u32 = SBIDX_OFFSET + 4;
impl SbValue {
    /// The `null` SB value constant.
    pub const NULL: SbValue = SbValue::_new(SBIDX_NULL);
    /// The `undefined` SB value constant.
    pub const UNDEFINED: SbValue = SbValue::_new(SBIDX_UNDEFINED);
    /// The `true` SB value constant.
    pub const TRUE: SbValue = SbValue::_new(SBIDX_TRUE);
    /// The `false` SB value constant.
    pub const FALSE: SbValue = SbValue::_new(SBIDX_FALSE);
    #[inline]
    const fn _new(idx: u32) -> SbValue {
        SbValue {
            idx,
            _marker: marker::PhantomData,
        }
    }
    /// Creates a new SB value which is a string.
    ///
    /// The utf-8 string provided is copied to the SB heap and the string will
    /// be owned by the SB garbage collector.
    #[allow(clippy::should_implement_trait)]
    #[inline]
    pub fn from_str(s: &str) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_string_new(s.as_ptr(), s.len())) }
    }
    /// Creates a new SB value which is a number.
    ///
    /// This function creates a SB value representing a number (a heap
    /// allocated number) and returns a handle to the SB version of it.
    #[inline]
    pub fn from_f64(n: f64) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_number_new(n)) }
    }
    /// Creates a new SB value which is a bigint from a string representing a number.
    ///
    /// This function creates a SB value representing a bigint (a heap
    /// allocated large integer) and returns a handle to the SB version of it.
    #[inline]
    pub fn bigint_from_str(s: &str) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bigint_from_str(s.as_ptr(), s.len())) }
    }
    /// Creates a new SB value which is a boolean.
    ///
    /// This function creates a SB object representing a boolean (a heap
    /// allocated boolean) and returns a handle to the SB version of it.
    #[inline]
    pub const fn from_bool(b: bool) -> SbValue {
        if b { SbValue::TRUE } else { SbValue::FALSE }
    }
    /// Creates a new SB value representing `undefined`.
    #[inline]
    pub const fn undefined() -> SbValue {
        SbValue::UNDEFINED
    }
    /// Creates a new SB value representing `null`.
    #[inline]
    pub const fn null() -> SbValue {
        SbValue::NULL
    }
    /// Creates a new SB symbol with the optional description specified.
    ///
    /// This function will invoke the `Symbol` constructor in SB and return the
    /// SB object corresponding to the symbol created.
    pub fn symbol(description: Option<&str>) -> SbValue {
        unsafe {
            match description {
                Some(description) => {
                    SbValue::_new(
                        __wasm_sb_bindgen_symbol_named_new(
                            description.as_ptr(),
                            description.len(),
                        ),
                    )
                }
                None => SbValue::_new(__wasm_sb_bindgen_symbol_anonymous_new()),
            }
        }
    }
    /// Returns the `f64` value of this SB value if it's an instance of a
    /// number.
    ///
    /// If this SB value is not an instance of a number then this returns
    /// `None`.
    #[inline]
    pub fn as_f64(&self) -> Option<f64> {
        unsafe { __wasm_sb_bindgen_number_get(self.idx).join() }
    }
    /// Tests whether this SB value is a SB string.
    #[inline]
    pub fn is_string(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_string(self.idx) == 1 }
    }
    /// If this SB value is a string value, this function copies the SB string
    /// value into wasm linear memory, encoded as UTF-8, and returns it as a
    /// Rust `String`.
    ///
    /// To avoid the copying and re-encoding, consider the
    /// `SbString::try_from()` function from [js-sys](https://docs.rs/js-sys)
    /// instead.
    ///
    /// If this SB value is not an instance of a string or if it's not valid
    /// utf-8 then this returns `None`.
    ///
    /// # UTF-16 vs UTF-8
    ///
    /// JavaScript strings in general are encoded as UTF-16, but Rust strings
    /// are encoded as UTF-8. This can cause the Rust string to look a bit
    /// different than the SB string sometimes. For more details see the
    /// [documentation about the `str` type][caveats] which contains a few
    /// caveats about the encodings.
    ///
    /// [caveats]: https://rustwasm.github.io/docs/wasm-bindgen/reference/types/str.html
    #[inline]
    pub fn as_string(&self) -> Option<String> {
        unsafe { FromWasmAbi::from_abi(__wasm_sb_bindgen_string_get(self.idx)) }
    }
    /// Returns the `bool` value of this SB value if it's an instance of a
    /// boolean.
    ///
    /// If this SB value is not an instance of a boolean then this returns
    /// `None`.
    #[inline]
    pub fn as_bool(&self) -> Option<bool> {
        unsafe {
            match __wasm_sb_bindgen_boolean_get(self.idx) {
                0 => Some(false),
                1 => Some(true),
                _ => None,
            }
        }
    }
    /// Tests whether this SB value is `null`
    #[inline]
    pub fn is_null(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_null(self.idx) == 1 }
    }
    /// Tests whether this SB value is `undefined`
    #[inline]
    pub fn is_undefined(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_undefined(self.idx) == 1 }
    }
    /// Tests whether the type of this SB value is `symbol`
    #[inline]
    pub fn is_symbol(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_symbol(self.idx) == 1 }
    }
    /// Tests whether `typeof self == "object" && self !== null`.
    #[inline]
    pub fn is_object(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_object(self.idx) == 1 }
    }
    /// Tests whether this SB value is an instance of Array.
    #[inline]
    pub fn is_array(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_array(self.idx) == 1 }
    }
    /// Tests whether the type of this SB value is `function`.
    #[inline]
    pub fn is_function(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_function(self.idx) == 1 }
    }
    /// Tests whether the type of this SB value is `bigint`.
    #[inline]
    pub fn is_bigint(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_bigint(self.idx) == 1 }
    }
    /// Applies the unary `typeof` SB operator on a `SbValue`.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)
    #[inline]
    pub fn sb_typeof(&self) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_typeof(self.idx)) }
    }
    /// Applies the binary `in` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in)
    #[inline]
    pub fn sb_in(&self, obj: &SbValue) -> bool {
        unsafe { __wasm_sb_bindgen_in(self.idx, obj.idx) == 1 }
    }
    /// Tests whether the value is ["truthy"].
    ///
    /// ["truthy"]: https://developer.mozilla.org/en-US/docs/Glossary/Truthy
    #[inline]
    pub fn is_truthy(&self) -> bool {
        !self.is_falsy()
    }
    /// Tests whether the value is ["falsy"].
    ///
    /// ["falsy"]: https://developer.mozilla.org/en-US/docs/Glossary/Falsy
    #[inline]
    pub fn is_falsy(&self) -> bool {
        unsafe { __wasm_sb_bindgen_is_falsy(self.idx) == 1 }
    }
    /// Compare two `SbValue`s for equality, using the `==` operator in SB.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality)
    #[inline]
    pub fn loose_eq(&self, other: &Self) -> bool {
        unsafe { __wasm_sb_bindgen_sbval_loose_eq(self.idx, other.idx) != 0 }
    }
    /// Applies the unary `~` SB operator on a `SbValue`.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT)
    #[inline]
    pub fn bit_not(&self) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bit_not(self.idx)) }
    }
    /// Applies the binary `>>>` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift)
    #[inline]
    pub fn unsigned_shr(&self, rhs: &Self) -> u32 {
        unsafe { __wasm_sb_bindgen_unsigned_shr(self.idx, rhs.idx) }
    }
    /// Applies the binary `/` SB operator on two `SbValue`s, catching and returning any `RangeError` thrown.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Division)
    #[inline]
    pub fn checked_div(&self, rhs: &Self) -> Self {
        unsafe { SbValue::_new(__wasm_sb_bindgen_checked_div(self.idx, rhs.idx)) }
    }
    /// Applies the binary `**` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Exponentiation)
    #[inline]
    pub fn pow(&self, rhs: &Self) -> Self {
        unsafe { SbValue::_new(__wasm_sb_bindgen_pow(self.idx, rhs.idx)) }
    }
    /// Applies the binary `<` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Less_than)
    #[inline]
    pub fn lt(&self, other: &Self) -> bool {
        unsafe { __wasm_sb_bindgen_lt(self.idx, other.idx) == 1 }
    }
    /// Applies the binary `<=` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Less_than_or_equal)
    #[inline]
    pub fn le(&self, other: &Self) -> bool {
        unsafe { __wasm_sb_bindgen_le(self.idx, other.idx) == 1 }
    }
    /// Applies the binary `>=` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Greater_than_or_equal)
    #[inline]
    pub fn ge(&self, other: &Self) -> bool {
        unsafe { __wasm_sb_bindgen_ge(self.idx, other.idx) == 1 }
    }
    /// Applies the binary `>` SB operator on the two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Greater_than)
    #[inline]
    pub fn gt(&self, other: &Self) -> bool {
        unsafe { __wasm_sb_bindgen_gt(self.idx, other.idx) == 1 }
    }
    /// Applies the unary `+` SB operator on a `SbValue`. Can throw.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus)
    #[inline]
    pub fn unchecked_into_f64(&self) -> f64 {
        unsafe { __wasm_sb_bindgen_as_number(self.idx) }
    }
}
impl PartialEq for SbValue {
    /// Compares two `SbValue`s for equality, using the `===` operator in SB.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality)
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        unsafe { __wasm_sb_bindgen_sbval_eq(self.idx, other.idx) != 0 }
    }
}
impl PartialEq<bool> for SbValue {
    #[inline]
    fn eq(&self, other: &bool) -> bool {
        self.as_bool() == Some(*other)
    }
}
impl PartialEq<str> for SbValue {
    #[inline]
    fn eq(&self, other: &str) -> bool {
        *self == SbValue::from_str(other)
    }
}
impl<'a> PartialEq<&'a str> for SbValue {
    #[inline]
    fn eq(&self, other: &&'a str) -> bool {
        <SbValue as PartialEq<str>>::eq(self, other)
    }
}
impl Not for &SbValue {
    type Output = bool;
    /// Applies the `!` SB operator on a `SbValue`.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT)
    #[inline]
    fn not(self) -> Self::Output {
        SbValue::is_falsy(self)
    }
}
impl Not for SbValue {
    type Output = <&'static SbValue as Not>::Output;
    #[inline]
    fn not(self) -> <&'static SbValue as Not>::Output {
        Not::not(&self)
    }
}
impl TryFrom<SbValue> for f64 {
    type Error = SbValue;
    /// Applies the unary `+` SB operator on a `SbValue`.
    /// Returns the numeric result on success, or the SB error value on error.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus)
    #[inline]
    fn try_from(val: SbValue) -> Result<Self, Self::Error> {
        f64::try_from(&val)
    }
}
impl TryFrom<&SbValue> for f64 {
    type Error = SbValue;
    /// Applies the unary `+` SB operator on a `SbValue`.
    /// Returns the numeric result on success, or the SB error value on error.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus)
    #[inline]
    fn try_from(val: &SbValue) -> Result<Self, Self::Error> {
        let sbval = unsafe { SbValue::_new(__wasm_sb_bindgen_try_into_number(val.idx)) };
        match sbval.as_f64() {
            Some(num) => Ok(num),
            None => Err(sbval),
        }
    }
}
impl Neg for &SbValue {
    type Output = SbValue;
    /// Applies the unary `-` SB operator on a `SbValue`.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_negation)
    #[inline]
    fn neg(self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_neg(self.idx)) }
    }
}
impl Neg for SbValue {
    type Output = <&'static SbValue as Neg>::Output;
    #[inline]
    fn neg(self) -> <&'static SbValue as Neg>::Output {
        Neg::neg(&self)
    }
}
impl BitAnd for &SbValue {
    type Output = SbValue;
    /// Applies the binary `&` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND)
    #[inline]
    fn bitand(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bit_and(self.idx, rhs.idx)) }
    }
}
impl<'a> BitAnd<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as BitAnd<&'static SbValue>>::Output;
    #[inline]
    fn bitand(
        self,
        other: SbValue,
    ) -> <&'static SbValue as BitAnd<&'static SbValue>>::Output {
        BitAnd::bitand(self, &other)
    }
}
impl BitAnd<&SbValue> for SbValue {
    type Output = <&'static SbValue as BitAnd<&'static SbValue>>::Output;
    #[inline]
    fn bitand(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as BitAnd<&'static SbValue>>::Output {
        BitAnd::bitand(&self, other)
    }
}
impl BitAnd<SbValue> for SbValue {
    type Output = <&'static SbValue as BitAnd<&'static SbValue>>::Output;
    #[inline]
    fn bitand(
        self,
        other: SbValue,
    ) -> <&'static SbValue as BitAnd<&'static SbValue>>::Output {
        BitAnd::bitand(&self, &other)
    }
}
impl BitOr for &SbValue {
    type Output = SbValue;
    /// Applies the binary `|` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR)
    #[inline]
    fn bitor(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bit_or(self.idx, rhs.idx)) }
    }
}
impl<'a> BitOr<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as BitOr<&'static SbValue>>::Output;
    #[inline]
    fn bitor(
        self,
        other: SbValue,
    ) -> <&'static SbValue as BitOr<&'static SbValue>>::Output {
        BitOr::bitor(self, &other)
    }
}
impl BitOr<&SbValue> for SbValue {
    type Output = <&'static SbValue as BitOr<&'static SbValue>>::Output;
    #[inline]
    fn bitor(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as BitOr<&'static SbValue>>::Output {
        BitOr::bitor(&self, other)
    }
}
impl BitOr<SbValue> for SbValue {
    type Output = <&'static SbValue as BitOr<&'static SbValue>>::Output;
    #[inline]
    fn bitor(
        self,
        other: SbValue,
    ) -> <&'static SbValue as BitOr<&'static SbValue>>::Output {
        BitOr::bitor(&self, &other)
    }
}
impl BitXor for &SbValue {
    type Output = SbValue;
    /// Applies the binary `^` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR)
    #[inline]
    fn bitxor(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bit_xor(self.idx, rhs.idx)) }
    }
}
impl<'a> BitXor<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as BitXor<&'static SbValue>>::Output;
    #[inline]
    fn bitxor(
        self,
        other: SbValue,
    ) -> <&'static SbValue as BitXor<&'static SbValue>>::Output {
        BitXor::bitxor(self, &other)
    }
}
impl BitXor<&SbValue> for SbValue {
    type Output = <&'static SbValue as BitXor<&'static SbValue>>::Output;
    #[inline]
    fn bitxor(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as BitXor<&'static SbValue>>::Output {
        BitXor::bitxor(&self, other)
    }
}
impl BitXor<SbValue> for SbValue {
    type Output = <&'static SbValue as BitXor<&'static SbValue>>::Output;
    #[inline]
    fn bitxor(
        self,
        other: SbValue,
    ) -> <&'static SbValue as BitXor<&'static SbValue>>::Output {
        BitXor::bitxor(&self, &other)
    }
}
impl Shl for &SbValue {
    type Output = SbValue;
    /// Applies the binary `<<` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Left_shift)
    #[inline]
    fn shl(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_shl(self.idx, rhs.idx)) }
    }
}
impl<'a> Shl<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Shl<&'static SbValue>>::Output;
    #[inline]
    fn shl(self, other: SbValue) -> <&'static SbValue as Shl<&'static SbValue>>::Output {
        Shl::shl(self, &other)
    }
}
impl Shl<&SbValue> for SbValue {
    type Output = <&'static SbValue as Shl<&'static SbValue>>::Output;
    #[inline]
    fn shl(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Shl<&'static SbValue>>::Output {
        Shl::shl(&self, other)
    }
}
impl Shl<SbValue> for SbValue {
    type Output = <&'static SbValue as Shl<&'static SbValue>>::Output;
    #[inline]
    fn shl(self, other: SbValue) -> <&'static SbValue as Shl<&'static SbValue>>::Output {
        Shl::shl(&self, &other)
    }
}
impl Shr for &SbValue {
    type Output = SbValue;
    /// Applies the binary `>>` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Right_shift)
    #[inline]
    fn shr(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_shr(self.idx, rhs.idx)) }
    }
}
impl<'a> Shr<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Shr<&'static SbValue>>::Output;
    #[inline]
    fn shr(self, other: SbValue) -> <&'static SbValue as Shr<&'static SbValue>>::Output {
        Shr::shr(self, &other)
    }
}
impl Shr<&SbValue> for SbValue {
    type Output = <&'static SbValue as Shr<&'static SbValue>>::Output;
    #[inline]
    fn shr(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Shr<&'static SbValue>>::Output {
        Shr::shr(&self, other)
    }
}
impl Shr<SbValue> for SbValue {
    type Output = <&'static SbValue as Shr<&'static SbValue>>::Output;
    #[inline]
    fn shr(self, other: SbValue) -> <&'static SbValue as Shr<&'static SbValue>>::Output {
        Shr::shr(&self, &other)
    }
}
impl Add for &SbValue {
    type Output = SbValue;
    /// Applies the binary `+` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Addition)
    #[inline]
    fn add(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_add(self.idx, rhs.idx)) }
    }
}
impl<'a> Add<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Add<&'static SbValue>>::Output;
    #[inline]
    fn add(self, other: SbValue) -> <&'static SbValue as Add<&'static SbValue>>::Output {
        Add::add(self, &other)
    }
}
impl Add<&SbValue> for SbValue {
    type Output = <&'static SbValue as Add<&'static SbValue>>::Output;
    #[inline]
    fn add(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Add<&'static SbValue>>::Output {
        Add::add(&self, other)
    }
}
impl Add<SbValue> for SbValue {
    type Output = <&'static SbValue as Add<&'static SbValue>>::Output;
    #[inline]
    fn add(self, other: SbValue) -> <&'static SbValue as Add<&'static SbValue>>::Output {
        Add::add(&self, &other)
    }
}
impl Sub for &SbValue {
    type Output = SbValue;
    /// Applies the binary `-` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Subtraction)
    #[inline]
    fn sub(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_sub(self.idx, rhs.idx)) }
    }
}
impl<'a> Sub<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Sub<&'static SbValue>>::Output;
    #[inline]
    fn sub(self, other: SbValue) -> <&'static SbValue as Sub<&'static SbValue>>::Output {
        Sub::sub(self, &other)
    }
}
impl Sub<&SbValue> for SbValue {
    type Output = <&'static SbValue as Sub<&'static SbValue>>::Output;
    #[inline]
    fn sub(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Sub<&'static SbValue>>::Output {
        Sub::sub(&self, other)
    }
}
impl Sub<SbValue> for SbValue {
    type Output = <&'static SbValue as Sub<&'static SbValue>>::Output;
    #[inline]
    fn sub(self, other: SbValue) -> <&'static SbValue as Sub<&'static SbValue>>::Output {
        Sub::sub(&self, &other)
    }
}
impl Div for &SbValue {
    type Output = SbValue;
    /// Applies the binary `/` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Division)
    #[inline]
    fn div(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_div(self.idx, rhs.idx)) }
    }
}
impl<'a> Div<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Div<&'static SbValue>>::Output;
    #[inline]
    fn div(self, other: SbValue) -> <&'static SbValue as Div<&'static SbValue>>::Output {
        Div::div(self, &other)
    }
}
impl Div<&SbValue> for SbValue {
    type Output = <&'static SbValue as Div<&'static SbValue>>::Output;
    #[inline]
    fn div(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Div<&'static SbValue>>::Output {
        Div::div(&self, other)
    }
}
impl Div<SbValue> for SbValue {
    type Output = <&'static SbValue as Div<&'static SbValue>>::Output;
    #[inline]
    fn div(self, other: SbValue) -> <&'static SbValue as Div<&'static SbValue>>::Output {
        Div::div(&self, &other)
    }
}
impl Mul for &SbValue {
    type Output = SbValue;
    /// Applies the binary `*` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Multiplication)
    #[inline]
    fn mul(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_mul(self.idx, rhs.idx)) }
    }
}
impl<'a> Mul<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Mul<&'static SbValue>>::Output;
    #[inline]
    fn mul(self, other: SbValue) -> <&'static SbValue as Mul<&'static SbValue>>::Output {
        Mul::mul(self, &other)
    }
}
impl Mul<&SbValue> for SbValue {
    type Output = <&'static SbValue as Mul<&'static SbValue>>::Output;
    #[inline]
    fn mul(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Mul<&'static SbValue>>::Output {
        Mul::mul(&self, other)
    }
}
impl Mul<SbValue> for SbValue {
    type Output = <&'static SbValue as Mul<&'static SbValue>>::Output;
    #[inline]
    fn mul(self, other: SbValue) -> <&'static SbValue as Mul<&'static SbValue>>::Output {
        Mul::mul(&self, &other)
    }
}
impl Rem for &SbValue {
    type Output = SbValue;
    /// Applies the binary `%` SB operator on two `SbValue`s.
    ///
    /// [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder)
    #[inline]
    fn rem(self, rhs: Self) -> Self::Output {
        unsafe { SbValue::_new(__wasm_sb_bindgen_rem(self.idx, rhs.idx)) }
    }
}
impl<'a> Rem<SbValue> for &'a SbValue {
    type Output = <&'static SbValue as Rem<&'static SbValue>>::Output;
    #[inline]
    fn rem(self, other: SbValue) -> <&'static SbValue as Rem<&'static SbValue>>::Output {
        Rem::rem(self, &other)
    }
}
impl Rem<&SbValue> for SbValue {
    type Output = <&'static SbValue as Rem<&'static SbValue>>::Output;
    #[inline]
    fn rem(
        self,
        other: &SbValue,
    ) -> <&'static SbValue as Rem<&'static SbValue>>::Output {
        Rem::rem(&self, other)
    }
}
impl Rem<SbValue> for SbValue {
    type Output = <&'static SbValue as Rem<&'static SbValue>>::Output;
    #[inline]
    fn rem(self, other: SbValue) -> <&'static SbValue as Rem<&'static SbValue>>::Output {
        Rem::rem(&self, &other)
    }
}
impl<'a> From<&'a str> for SbValue {
    #[inline]
    fn from(s: &'a str) -> SbValue {
        SbValue::from_str(s)
    }
}
impl<T> From<*mut T> for SbValue {
    #[inline]
    fn from(s: *mut T) -> SbValue {
        SbValue::from(s as usize)
    }
}
impl<T> From<*const T> for SbValue {
    #[inline]
    fn from(s: *const T) -> SbValue {
        SbValue::from(s as usize)
    }
}
impl<'a> From<&'a String> for SbValue {
    #[inline]
    fn from(s: &'a String) -> SbValue {
        SbValue::from_str(s)
    }
}
impl From<String> for SbValue {
    #[inline]
    fn from(s: String) -> SbValue {
        SbValue::from_str(&s)
    }
}
impl TryFrom<SbValue> for String {
    type Error = SbValue;
    fn try_from(value: SbValue) -> Result<Self, Self::Error> {
        match value.as_string() {
            Some(s) => Ok(s),
            None => Err(value),
        }
    }
}
impl TryFromSbValue for String {
    type Error = SbValue;
    fn try_from_sb_value(value: SbValue) -> Result<Self, Self::Error> {
        match value.as_string() {
            Some(s) => Ok(s),
            None => Err(value),
        }
    }
}
impl From<bool> for SbValue {
    #[inline]
    fn from(s: bool) -> SbValue {
        SbValue::from_bool(s)
    }
}
impl<'a, T> From<&'a T> for SbValue
where
    T: SbCast,
{
    #[inline]
    fn from(s: &'a T) -> SbValue {
        s.as_ref().clone()
    }
}
impl<T> From<Option<T>> for SbValue
where
    SbValue: From<T>,
{
    #[inline]
    fn from(s: Option<T>) -> SbValue {
        match s {
            Some(s) => s.into(),
            None => SbValue::undefined(),
        }
    }
}
impl SbCast for SbValue {
    #[inline]
    fn instanceof(_val: &SbValue) -> bool {
        true
    }
    #[inline]
    fn unchecked_from_sb(val: SbValue) -> Self {
        val
    }
    #[inline]
    fn unchecked_from_sb_ref(val: &SbValue) -> &Self {
        val
    }
}
impl AsRef<SbValue> for SbValue {
    #[inline]
    fn as_ref(&self) -> &SbValue {
        self
    }
}
impl PartialEq<i8> for SbValue {
    #[inline]
    fn eq(&self, other: &i8) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<i8> for SbValue {
    #[inline]
    fn from(n: i8) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<u8> for SbValue {
    #[inline]
    fn eq(&self, other: &u8) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<u8> for SbValue {
    #[inline]
    fn from(n: u8) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<i16> for SbValue {
    #[inline]
    fn eq(&self, other: &i16) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<i16> for SbValue {
    #[inline]
    fn from(n: i16) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<u16> for SbValue {
    #[inline]
    fn eq(&self, other: &u16) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<u16> for SbValue {
    #[inline]
    fn from(n: u16) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<i32> for SbValue {
    #[inline]
    fn eq(&self, other: &i32) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<i32> for SbValue {
    #[inline]
    fn from(n: i32) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<u32> for SbValue {
    #[inline]
    fn eq(&self, other: &u32) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<u32> for SbValue {
    #[inline]
    fn from(n: u32) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<f32> for SbValue {
    #[inline]
    fn eq(&self, other: &f32) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<f32> for SbValue {
    #[inline]
    fn from(n: f32) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
impl PartialEq<f64> for SbValue {
    #[inline]
    fn eq(&self, other: &f64) -> bool {
        self.as_f64() == Some(f64::from(*other))
    }
}
impl From<f64> for SbValue {
    #[inline]
    fn from(n: f64) -> SbValue {
        SbValue::from_f64(n.into())
    }
}
fn bigint_get_as_i64(v: &SbValue) -> Option<i64> {
    unsafe { __wasm_sb_bindgen_bigint_get_as_i64(v.idx).join() }
}
impl TryFrom<SbValue> for i64 {
    type Error = SbValue;
    #[inline]
    fn try_from(v: SbValue) -> Result<Self, SbValue> {
        bigint_get_as_i64(&v)
            .map(|as_i64| as_i64 as Self)
            .filter(|as_self| v == *as_self)
            .ok_or(v)
    }
}
impl TryFrom<SbValue> for u64 {
    type Error = SbValue;
    #[inline]
    fn try_from(v: SbValue) -> Result<Self, SbValue> {
        bigint_get_as_i64(&v)
            .map(|as_i64| as_i64 as Self)
            .filter(|as_self| v == *as_self)
            .ok_or(v)
    }
}
impl TryFrom<SbValue> for i128 {
    type Error = SbValue;
    #[inline]
    fn try_from(v: SbValue) -> Result<Self, SbValue> {
        let lo = match bigint_get_as_i64(&v) {
            Some(lo) => lo as u64,
            None => return Err(v),
        };
        let hi = v >> SbValue::from(64_u64);
        let hi = <i64>::try_from(hi)?;
        Ok(Self::from(hi) << 64 | Self::from(lo))
    }
}
impl TryFrom<SbValue> for u128 {
    type Error = SbValue;
    #[inline]
    fn try_from(v: SbValue) -> Result<Self, SbValue> {
        let lo = match bigint_get_as_i64(&v) {
            Some(lo) => lo as u64,
            None => return Err(v),
        };
        let hi = v >> SbValue::from(64_u64);
        let hi = <u64>::try_from(hi)?;
        Ok(Self::from(hi) << 64 | Self::from(lo))
    }
}
impl PartialEq<i64> for SbValue {
    #[inline]
    fn eq(&self, other: &i64) -> bool {
        self == &SbValue::from(*other)
    }
}
impl From<i64> for SbValue {
    #[inline]
    fn from(n: i64) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bigint_from_i64(n)) }
    }
}
impl PartialEq<u64> for SbValue {
    #[inline]
    fn eq(&self, other: &u64) -> bool {
        self == &SbValue::from(*other)
    }
}
impl From<u64> for SbValue {
    #[inline]
    fn from(n: u64) -> SbValue {
        unsafe { SbValue::_new(__wasm_sb_bindgen_bigint_from_u64(n)) }
    }
}
impl PartialEq<i128> for SbValue {
    #[inline]
    fn eq(&self, other: &i128) -> bool {
        self == &SbValue::from(*other)
    }
}
impl From<i128> for SbValue {
    #[inline]
    fn from(n: i128) -> SbValue {
        unsafe {
            SbValue::_new(__wasm_sb_bindgen_bigint_from_i128((n >> 64) as i64, n as u64))
        }
    }
}
impl PartialEq<u128> for SbValue {
    #[inline]
    fn eq(&self, other: &u128) -> bool {
        self == &SbValue::from(*other)
    }
}
impl From<u128> for SbValue {
    #[inline]
    fn from(n: u128) -> SbValue {
        unsafe {
            SbValue::_new(__wasm_sb_bindgen_bigint_from_u128((n >> 64) as u64, n as u64))
        }
    }
}
impl PartialEq<usize> for SbValue {
    #[inline]
    fn eq(&self, other: &usize) -> bool {
        *self == (*other as u32)
    }
}
impl From<usize> for SbValue {
    #[inline]
    fn from(n: usize) -> Self {
        Self::from(n as u32)
    }
}
impl PartialEq<isize> for SbValue {
    #[inline]
    fn eq(&self, other: &isize) -> bool {
        *self == (*other as i32)
    }
}
impl From<isize> for SbValue {
    #[inline]
    fn from(n: isize) -> Self {
        Self::from(n as i32)
    }
}
#[cfg(
    all(target_arch = "wasm32", not(any(target_os = "emscripten", target_os = "wasi")))
)]
#[link(wasm_import_module = "__wasm_sb_bindgen_placeholder__")]
extern "C" {
    fn __wasm_sb_bindgen_object_clone_ref(idx: u32) -> u32;
    fn __wasm_sb_bindgen_object_drop_ref(idx: u32) -> ();
    fn __wasm_sb_bindgen_string_new(ptr: *const u8, len: usize) -> u32;
    fn __wasm_sb_bindgen_number_new(f: f64) -> u32;
    fn __wasm_sb_bindgen_bigint_from_str(ptr: *const u8, len: usize) -> u32;
    fn __wasm_sb_bindgen_bigint_from_i64(n: i64) -> u32;
    fn __wasm_sb_bindgen_bigint_from_u64(n: u64) -> u32;
    fn __wasm_sb_bindgen_bigint_from_i128(hi: i64, lo: u64) -> u32;
    fn __wasm_sb_bindgen_bigint_from_u128(hi: u64, lo: u64) -> u32;
    fn __wasm_sb_bindgen_symbol_named_new(ptr: *const u8, len: usize) -> u32;
    fn __wasm_sb_bindgen_symbol_anonymous_new() -> u32;
    fn __wasm_sb_bindgen_externref_heap_live_count() -> u32;
    fn __wasm_sb_bindgen_is_null(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_undefined(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_symbol(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_object(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_array(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_function(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_string(idx: u32) -> u32;
    fn __wasm_sb_bindgen_is_bigint(idx: u32) -> u32;
    fn __wasm_sb_bindgen_typeof(idx: u32) -> u32;
    fn __wasm_sb_bindgen_in(prop: u32, obj: u32) -> u32;
    fn __wasm_sb_bindgen_is_falsy(idx: u32) -> u32;
    fn __wasm_sb_bindgen_as_number(idx: u32) -> f64;
    fn __wasm_sb_bindgen_try_into_number(idx: u32) -> u32;
    fn __wasm_sb_bindgen_neg(idx: u32) -> u32;
    fn __wasm_sb_bindgen_bit_and(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_bit_or(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_bit_xor(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_bit_not(idx: u32) -> u32;
    fn __wasm_sb_bindgen_shl(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_shr(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_unsigned_shr(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_add(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_sub(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_div(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_checked_div(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_mul(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_rem(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_pow(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_lt(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_le(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_ge(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_gt(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_number_get(idx: u32) -> WasmRet<Option<f64>>;
    fn __wasm_sb_bindgen_boolean_get(idx: u32) -> u32;
    fn __wasm_sb_bindgen_string_get(idx: u32) -> WasmSlice;
    fn __wasm_sb_bindgen_bigint_get_as_i64(idx: u32) -> WasmRet<Option<i64>>;
    fn __wasm_sb_bindgen_debug_string(ret: *mut [usize; 2], idx: u32) -> ();
    fn __wasm_sb_bindgen_throw(a: *const u8, b: usize) -> !;
    fn __wasm_sb_bindgen_rethrow(a: u32) -> !;
    fn __wasm_sb_bindgen_error_new(a: *const u8, b: usize) -> u32;
    fn __wasm_sb_bindgen_cb_drop(idx: u32) -> u32;
    fn __wasm_sb_bindgen_describe(v: u32) -> ();
    fn __wasm_sb_bindgen_describe_closure(a: u32, b: u32, c: u32) -> u32;
    fn __wasm_sb_bindgen_json_parse(ptr: *const u8, len: usize) -> u32;
    fn __wasm_sb_bindgen_json_serialize(idx: u32) -> WasmSlice;
    fn __wasm_sb_bindgen_sbval_eq(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_sbval_loose_eq(a: u32, b: u32) -> u32;
    fn __wasm_sb_bindgen_copy_to_typed_array(ptr: *const u8, len: usize, idx: u32) -> ();
    fn __wasm_sb_bindgen_not(idx: u32) -> u32;
    fn __wasm_sb_bindgen_exports() -> u32;
    fn __wasm_sb_bindgen_memory() -> u32;
    fn __wasm_sb_bindgen_module() -> u32;
    fn __wasm_sb_bindgen_function_table() -> u32;
}
impl Clone for SbValue {
    #[inline]
    fn clone(&self) -> SbValue {
        unsafe {
            let idx = __wasm_sb_bindgen_object_clone_ref(self.idx);
            SbValue::_new(idx)
        }
    }
}
#[cfg(not(feature = "std"))]
impl fmt::Debug for SbValue {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("SbValue")
    }
}
impl Drop for SbValue {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            if true {
                if !(self.idx >= SBIDX_OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("free of stack slot {0}", self.idx),
                        );
                    }
                }
            }
            if self.idx >= SBIDX_RESERVED {
                __wasm_sb_bindgen_object_drop_ref(self.idx);
            }
        }
    }
}
impl Default for SbValue {
    fn default() -> Self {
        Self::UNDEFINED
    }
}
#[cold]
#[inline(never)]
#[deprecated(note = "renamed to `throw_str`")]
#[doc(hidden)]
pub fn throw(s: &str) -> ! {
    throw_str(s)
}
#[cold]
#[inline(never)]
pub fn throw_str(s: &str) -> ! {
    unsafe {
        __wasm_sb_bindgen_throw(s.as_ptr(), s.len());
    }
}
#[cold]
#[inline(never)]
pub fn throw_val(s: SbValue) -> ! {
    unsafe {
        let idx = s.idx;
        mem::forget(s);
        __wasm_sb_bindgen_rethrow(idx);
    }
}
pub fn externref_heap_live_count() -> u32 {
    unsafe { __wasm_sb_bindgen_externref_heap_live_count() }
}
#[doc(hidden)]
pub fn anyref_heap_live_count() -> u32 {
    externref_heap_live_count()
}
pub trait UnwrapThrowExt<T>: Sized {
    /// Unwrap this `Option` or `Result`, but instead of panicking on failure,
    /// throw an exception to JavaScript.
    #[track_caller]
    fn unwrap_throw(self) -> T {
        if false {
            let loc = core::panic::Location::caller();
            let msg = {
                let res = ::alloc::fmt::format(
                    format_args!(
                        "`unwrap_throw` failed ({0}:{1}:{2})",
                        loc.file(),
                        loc.line(),
                        loc.column(),
                    ),
                );
                res
            };
            self.expect_throw(&msg)
        } else {
            self.expect_throw("`unwrap_throw` failed")
        }
    }
    /// Unwrap this container's `T` value, or throw an error to SB with the
    /// given message if the `T` value is unavailable (e.g. an `Option<T>` is
    /// `None`).
    #[track_caller]
    fn expect_throw(self, message: &str) -> T;
}
impl<T> UnwrapThrowExt<T> for Option<T> {
    #[track_caller]
    fn expect_throw(self, message: &str) -> T {
        if true {
            match self {
                Some(val) => val,
                None => throw_str(message),
            }
        } else {
            self.expect(message)
        }
    }
}
impl<T, E> UnwrapThrowExt<T> for Result<T, E>
where
    E: core::fmt::Debug,
{
    #[track_caller]
    fn expect_throw(self, message: &str) -> T {
        if true {
            match self {
                Ok(val) => val,
                Err(_) => throw_str(message),
            }
        } else {
            self.expect(message)
        }
    }
}
pub fn module() -> SbValue {
    unsafe { SbValue::_new(__wasm_sb_bindgen_module()) }
}
pub fn exports() -> SbValue {
    unsafe { SbValue::_new(__wasm_sb_bindgen_exports()) }
}
pub fn memory() -> SbValue {
    unsafe { SbValue::_new(__wasm_sb_bindgen_memory()) }
}
pub fn function_table() -> SbValue {
    unsafe { SbValue::_new(__wasm_sb_bindgen_function_table()) }
}
#[doc(hidden)]
pub mod __rt {
    use crate::SbValue;
    use core::borrow::{Borrow, BorrowMut};
    use core::cell::{Cell, UnsafeCell};
    use core::convert::Infallible;
    use core::ops::{Deref, DerefMut};
    pub extern crate core;
    #[inline]
    pub fn assert_not_null<T>(s: *mut T) {
        if s.is_null() {
            throw_null();
        }
    }
    #[cold]
    #[inline(never)]
    fn throw_null() -> ! {
        super::throw_str("null pointer passed to rust");
    }
    /// A vendored version of `RefCell` from the standard library.
    ///
    /// Now why, you may ask, would we do that? Surely `RefCell` in libstd is
    /// quite good. And you're right, it is indeed quite good! Functionally
    /// nothing more is needed from `RefCell` in the standard library but for
    /// now this crate is also sort of optimizing for compiled code size.
    ///
    /// One major factor to larger binaries in Rust is when a panic happens.
    /// Panicking in the standard library involves a fair bit of machinery
    /// (formatting, panic hooks, synchronization, etc). It's all worthwhile if
    /// you need it but for something like `WasmRefCell` here we don't actually
    /// need all that!
    ///
    /// This is just a wrapper around all Rust objects passed to SB intended to
    /// guard accidental reentrancy, so this vendored version is intended solely
    /// to not panic in libstd. Instead when it "panics" it calls our `throw`
    /// function in this crate which raises an error in SB.
    pub struct WasmRefCell<T: ?Sized> {
        borrow: Cell<usize>,
        value: UnsafeCell<T>,
    }
    impl<T: ?Sized> WasmRefCell<T> {
        pub fn new(value: T) -> WasmRefCell<T>
        where
            T: Sized,
        {
            WasmRefCell {
                value: UnsafeCell::new(value),
                borrow: Cell::new(0),
            }
        }
        pub fn get_mut(&mut self) -> &mut T {
            unsafe { &mut *self.value.get() }
        }
        pub fn borrow(&self) -> Ref<T> {
            unsafe {
                if self.borrow.get() == usize::max_value() {
                    borrow_fail();
                }
                self.borrow.set(self.borrow.get() + 1);
                Ref {
                    value: &*self.value.get(),
                    borrow: &self.borrow,
                }
            }
        }
        pub fn borrow_mut(&self) -> RefMut<T> {
            unsafe {
                if self.borrow.get() != 0 {
                    borrow_fail();
                }
                self.borrow.set(usize::max_value());
                RefMut {
                    value: &mut *self.value.get(),
                    borrow: &self.borrow,
                }
            }
        }
        pub fn into_inner(self) -> T
        where
            T: Sized,
        {
            self.value.into_inner()
        }
    }
    pub struct Ref<'b, T: ?Sized + 'b> {
        value: &'b T,
        borrow: &'b Cell<usize>,
    }
    impl<'b, T: ?Sized> Deref for Ref<'b, T> {
        type Target = T;
        #[inline]
        fn deref(&self) -> &T {
            self.value
        }
    }
    impl<'b, T: ?Sized> Borrow<T> for Ref<'b, T> {
        #[inline]
        fn borrow(&self) -> &T {
            self.value
        }
    }
    impl<'b, T: ?Sized> Drop for Ref<'b, T> {
        fn drop(&mut self) {
            self.borrow.set(self.borrow.get() - 1);
        }
    }
    pub struct RefMut<'b, T: ?Sized + 'b> {
        value: &'b mut T,
        borrow: &'b Cell<usize>,
    }
    impl<'b, T: ?Sized> Deref for RefMut<'b, T> {
        type Target = T;
        #[inline]
        fn deref(&self) -> &T {
            self.value
        }
    }
    impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {
        #[inline]
        fn deref_mut(&mut self) -> &mut T {
            self.value
        }
    }
    impl<'b, T: ?Sized> Borrow<T> for RefMut<'b, T> {
        #[inline]
        fn borrow(&self) -> &T {
            self.value
        }
    }
    impl<'b, T: ?Sized> BorrowMut<T> for RefMut<'b, T> {
        #[inline]
        fn borrow_mut(&mut self) -> &mut T {
            self.value
        }
    }
    impl<'b, T: ?Sized> Drop for RefMut<'b, T> {
        fn drop(&mut self) {
            self.borrow.set(0);
        }
    }
    fn borrow_fail() -> ! {
        super::throw_str(
            "recursive use of an object detected which would lead to \
             unsafe aliasing in rust",
        );
    }
    /// This is a curious function necessary to get wasm-bindgen working today,
    /// and it's a bit of an unfortunate hack.
    ///
    /// The general problem is that somehow we need the above two symbols to
    /// exist in the final output binary (__wasm_sb_bindgen_malloc and
    /// __wasm_sb_bindgen_free). These symbols may be called by SB for various
    /// bindings, so we for sure need to make sure they're exported.
    ///
    /// The problem arises, though, when what if no Rust code uses the symbols?
    /// For all intents and purposes it looks to LLVM and the linker like the
    /// above two symbols are dead code, so they're completely discarded!
    ///
    /// Specifically what happens is this:
    ///
    /// * The above two symbols are generated into some object file inside of
    ///   libwasm_bindgen.rlib
    /// * The linker, LLD, will not load this object file unless *some* symbol
    ///   is loaded from the object. In this case, if the Rust code never calls
    ///   __wasm_sb_bindgen_malloc or __wasm_sb_bindgen_free then the symbols never get linked
    ///   in.
    /// * Later when `wasm-bindgen` attempts to use the symbols they don't
    ///   exist, causing an error.
    ///
    /// This function is a weird hack for this problem. We inject a call to this
    /// function in all generated code. Usage of this function should then
    /// ensure that the above two intrinsics are translated.
    ///
    /// Due to how rustc creates object files this function (and anything inside
    /// it) will be placed into the same object file as the two intrinsics
    /// above. That means if this function is called and referenced we'll pull
    /// in the object file and link the intrinsics.
    ///
    /// Ideas for how to improve this are most welcome!
    pub fn link_mem_intrinsics() {
        crate::externref::link_intrinsics();
    }
    static mut GLOBAL_EXNDATA: [u32; 2] = [0; 2];
    #[no_mangle]
    pub unsafe extern "C" fn __wasm_sb_bindgen_exn_store(idx: u32) {
        if true {
            match (&GLOBAL_EXNDATA[0], &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            };
        }
        GLOBAL_EXNDATA[0] = 1;
        GLOBAL_EXNDATA[1] = idx;
    }
    pub fn take_last_exception() -> Result<(), super::SbValue> {
        unsafe {
            let ret = if GLOBAL_EXNDATA[0] == 1 {
                Err(super::SbValue::_new(GLOBAL_EXNDATA[1]))
            } else {
                Ok(())
            };
            GLOBAL_EXNDATA[0] = 0;
            GLOBAL_EXNDATA[1] = 0;
            ret
        }
    }
    /// An internal helper trait for usage in `#[wasm_bindgen]` on `async`
    /// functions to convert the return value of the function to
    /// `Result<SbValue, SbValue>` which is what we'll return to SB (where an
    /// error is a failed future).
    pub trait IntoSbResult {
        fn into_js_result(self) -> Result<SbValue, SbValue>;
    }
    impl IntoSbResult for () {
        fn into_js_result(self) -> Result<SbValue, SbValue> {
            Ok(SbValue::undefined())
        }
    }
    impl<T: Into<SbValue>> IntoSbResult for T {
        fn into_js_result(self) -> Result<SbValue, SbValue> {
            Ok(self.into())
        }
    }
    impl<T: Into<SbValue>, E: Into<SbValue>> IntoSbResult for Result<T, E> {
        fn into_js_result(self) -> Result<SbValue, SbValue> {
            match self {
                Ok(e) => Ok(e.into()),
                Err(e) => Err(e.into()),
            }
        }
    }
    impl<E: Into<SbValue>> IntoSbResult for Result<(), E> {
        fn into_js_result(self) -> Result<SbValue, SbValue> {
            match self {
                Ok(()) => Ok(SbValue::undefined()),
                Err(e) => Err(e.into()),
            }
        }
    }
    /// An internal helper trait for usage in `#[wasm_bindgen(start)]`
    /// functions to throw the error (if it is `Err`).
    pub trait Start {
        fn start(self);
    }
    impl Start for () {
        #[inline]
        fn start(self) {}
    }
    impl<E: Into<SbValue>> Start for Result<(), E> {
        #[inline]
        fn start(self) {
            if let Err(e) = self {
                crate::throw_val(e.into());
            }
        }
    }
    /// An internal helper struct for usage in `#[wasm_bindgen(main)]`
    /// functions to throw the error (if it is `Err`).
    pub struct MainWrapper<T>(pub Option<T>);
    pub trait Main {
        fn __wasm_bindgen_main(&mut self);
    }
    impl Main for &mut &mut MainWrapper<()> {
        #[inline]
        fn __wasm_bindgen_main(&mut self) {}
    }
    impl Main for &mut &mut MainWrapper<Infallible> {
        #[inline]
        fn __wasm_bindgen_main(&mut self) {}
    }
    impl<E: Into<SbValue>> Main for &mut &mut MainWrapper<Result<(), E>> {
        #[inline]
        fn __wasm_bindgen_main(&mut self) {
            if let Err(e) = self.0.take().unwrap() {
                crate::throw_val(e.into());
            }
        }
    }
    impl<E: std::fmt::Debug> Main for &mut MainWrapper<Result<(), E>> {
        #[inline]
        fn __wasm_bindgen_main(&mut self) {
            if let Err(e) = self.0.take().unwrap() {
                crate::throw_str(
                    &{
                        let res = ::alloc::fmt::format(format_args!("{0:?}", e));
                        res
                    },
                );
            }
        }
    }
}
pub struct SbError {
    value: SbValue,
}
#[automatically_derived]
impl ::core::clone::Clone for SbError {
    #[inline]
    fn clone(&self) -> SbError {
        SbError {
            value: ::core::clone::Clone::clone(&self.value),
        }
    }
}
impl SbError {
    /// Construct a JavaScript `Error` object with a string message
    #[inline]
    pub fn new(s: &str) -> SbError {
        Self {
            value: unsafe {
                SbValue::_new(crate::__wasm_sb_bindgen_error_new(s.as_ptr(), s.len()))
            },
        }
    }
}
impl From<SbError> for SbValue {
    fn from(error: SbError) -> Self {
        error.value
    }
}
